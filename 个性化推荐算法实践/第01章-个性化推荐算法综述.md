[TOC]

# 个性化推荐算法实践第01章个性化推荐算法综述

## 第01部分个性化推荐算法综述

个性化推荐算法综述部分，主要介绍个性化推荐算法综述，本课程内容大纲以及本课程所需要准备的编程环境与基础知识。

### 个性化推荐算法综述

介绍本课程的主要内容与需要准备的知识，并介绍个性化推荐在工业界的落地场景与架构

#### 1、什么是推荐系统？

在介绍推荐算法之前需要先介绍一下什么是信息过载。

信息过载就是信息的数量远超于人手工可以遍历的数量。比如，当你没有目的性的去逛超市，你不可能把所有的商品都看一遍都有什么。同样，无论是去书店看书，还是在电影网站上搜索电影，这些物品的量级对于没有目的性、需求性的用户而言都是信息过载。

那么什么是推荐系统呢？

就是当用户的目的不明确、且该服务对于用户而言构成了信息过载；但该系统基于一定的策略规则，将物品进行了排序，并将前面的物品展示给了用户，这样的系统就可以称之为推荐系统。

举例说明，在网站购物过程中，无论是天猫或者京东这样的平台，如果我们有明确的需求去搜索框里检索。如希望买啤酒，那么检索结果就是很多种类的啤酒；如果没有明确的需求，就会有猜你喜欢等等模块，这些模块就是推荐系统基于一定的规则策略计算出来的，这些规则策略就是个性化推荐算法。

#### 2、个性化推荐算法在系统中所起到的作用

- 推荐系统在工业界落地较成功的三大产品：电商、信息流、地图基于位置服务的（LBS）的推荐

推荐系统如今在工业界中落地较为成功的有三类产品，分别是电商、地图、基于LBS的推荐。电商中，用户需要面对数以十万计的新闻与短视频，地图中用户需要面对数以百万计的餐馆等等；但是用户首先看到的都不会是全部的内容，只会是几个或者几十个新闻、短视频、餐馆等等，决定从物品海洋里选择哪些展现给用户的就是个性化推荐算法。

如果推荐的精确，也就是说该推荐系统推荐的恰好是用户想要的、或者是促进了用户的需求，那么就会推动用户在该电商上进行消费、停留、阅读等等。所以，在推荐系统中最为重要的就是个性化推荐算法。

#### 3、如何衡量个性化推荐算法在产品中起到的作用

分为线上和线下两个部分。其中线下部分主要依托于模型本身的评估指标，比如个性化召回算法中模型的准确率等等；在线上，基于业务本身的核心指标，比如基于信息流产品中的平均阅读时长等等。

- 信息流中的点击率 ctr 与停留时长 dwell time
- 电商中的*GMV*(Gross Merchandise Volume,网站成交金额)

#### 4、推荐算法介绍

包括：个性化召回算法、个性化排序算法

[![1563154737612](https://i.loli.net/2020/08/19/lmfuOngqpTDsQeG.png)](https://enfangzhong.github.io/2019/06/01/个性化推荐算法实践第01章个性化推荐算法综述/1563154737612.png)

#### 5、评估指标：

包括：在线评估指标和离线评估指标

[![1563154861816](https://i.loli.net/2020/08/19/Y3KIl8BPdC7crWb.png)](https://enfangzhong.github.io/2019/06/01/个性化推荐算法实践第01章个性化推荐算法综述/1563154861816.png)

### 个性化召回

#### 1、什么是个性化召回？

- 在item全集中选取一部分作为候选集。

    这里就存在一个问题，就是说为什么要选取一部分作为作为候选集，而不是全部？其原因在于：1.不同的用户不会喜欢所有类型的item；2.基于服务性能的考虑，如果选择了全部的item作为候选集，对于后续的排序就将耗费大量的时间，对于整体推荐的后端，服务响应时间将会是灾难性的。

- 根据用户的属性行为上下文等信息从物品全集中选取其感兴趣的物品作为候选集。

下面举例说明：

如果某个推荐系统中，物品全集是如下左图中9个item，这里有两个用户A和B，他们分别对不同的item感兴趣。这里拿信息流产品举例，如果user A对体育类新闻感兴趣，user B对娱乐类新闻感兴趣，那就按照简单的类别召回，得到结果如下右图所示。

在候选集{a,b,c,….,g,h,i}中为User A,User B选取一部分item作为候选集。

[![1563155318297](https://i.loli.net/2020/08/19/1KJXhFdLqa3c65G.png)](https://enfangzhong.github.io/2019/06/01/个性化推荐算法实践第01章个性化推荐算法综述/1563155318297.png)

#### 2、召回的重要作用

1、召回决定了最终推荐结果的天花板

为什么这么说呢？这里先看一下推荐系统的整体架构，工业中的个性化推荐系统中的策略部分的架构主要由一下三部分构成：召回、排序、以及最后的策略调整部分，其中召回部分包括各路个性化召回之后将所有的item merge进入rank部分，rank只是调整召回完item的展现顺序，rank完之后还有一些策略的调整，比如信息流场景中的控制相同作者的数目等等，所以可以看到个性化召回的候选集是多么的重要，因为最终展现给用户的就是从这个候选集中选出来的。那么就可能会有疑问，为什么不能将所有的item进行排序？这是为了保证后端响应时间。

[![1563155445050](https://cdn.jsdelivr.net/gh/Shadowalker1995/images/2020/1563155445050.png)](https://enfangzhong.github.io/2019/06/01/个性化推荐算法实践第01章个性化推荐算法综述/1563155445050.png)

与用户离的最近的是端，在移动互联网的时代主要的流量集中在了移动app也可以是网站前端。连接接前后端的是WEB API层。WEB层主要给APP端提供API服务，解析端上发来的请求，调用后端rpc服务。得到的结果投全到端上。web api层尽量不做策略业务逻辑，但是会做一些诸如log写实时信息队列，或写分布式存储这样的事情来方便后续的数据分析和模型训练。

最后是后端的RPC服务。个性化推荐算法主要发挥作用的部分。

RPC服务的三大策略部分。

- 第一：个性化召回，基于用户的行为，通过算法模型来为用户精准推荐。或基于用户画像的标签推荐同类型的item。举个栗子，如果某个用户过往经常点击体育类的item，那么用户画像就给她标上体育的lable。那么有较新的体育类新闻，会优先推荐给改用户。召回决定了最终推荐结果的天花板，因为这一步决定了候选集。
- 第二部分：排序部分。第一部分召回了用户感兴趣的物品集合后，我们需要决策 出展现给用户的顺序。好的顺序可以让用户在列表的开始找到自己的所需，完成转化。因为用户的每一次下拉都是有成本的，如何不能在最初的几屏里，显示用户的所需，用户就很可能流失掉。结合刚才召回所举的例子，给用户召回了体育类的item，不同的item可能会有不同的浏览人数，评论人数，发布时间，不同的字数，不同的时长，不同的发布时间等等，同样该用户也有体育类的细分的倾向性。
- 第三部分：策略调整部分，基于业务场景的策略调整部分。由于召回和排序大多数是基于模型来做的，所以基于业务场景的策略调整部分可以增加一些规则来fit业务场景。比如在信息流场景中，我们不希望给用户一直连续推荐同一个作者的新闻，我们可以加一些打散的策略。

2、个性化召回解析

个性化召回算法分为哪几大类？

- 基于用户行为的（也就是用户基于推荐系统推荐给他的item点击或者没点。）

     CF(基于邻域的算法：user CF item CF)、矩阵分解、基于图的推荐（graph-based model）——基于图的随机游走算法：PersonalRank

这一类的个性化召回算法总体来说就是推荐结果的可解释性较强，比较通俗易懂，但是缺少一些新颖性。

- 基于user profile的

    经过用户的自然属性，也就是说经过用户的偏好统计，那么基于这个统计的类别去召回。推荐效果不错，但是可扩展性较差。也就是说一旦用户被标上了某一个类别或者某几个类别的标签之后，很难迁移到其余的一些标签。

    基于用户的偏好的统计的类别类召回。效果不错，可扩展性比较差。

- 隐语义模型Latent Factorization Model(LFM)

    新颖性、创新性十足，但是可解释性不是那么强。

3、工业界个性化召回架构

[![1563156562109](https://cdn.jsdelivr.net/gh/Shadowalker1995/images/2020/1563156562109.png)](https://enfangzhong.github.io/2019/06/01/个性化推荐算法实践第01章个性化推荐算法综述/1563156562109.png)

整体的召回架构可以分为两大类：

第一大类是离线模型。根据用户行为基于离线的model file算出推荐结果，这些推荐结果可以是用户喜欢哪些item集合，也可以是item之间的相似度文件 ，计算出具有某种lable的item的排序。然后离线计算好的排序的文件写入KV存储。在用户访问服务的时候，Recall部分直接从KV中读取。因为我们直接存储的是item ID,我们读取到的item id的时候还需要去Detail Server中得到每个item id的详情，然后将详情拼接好传给rank。(在线的server recall部分直接调用这个结果，拿到ID之后访问detail server得到详情，再往rank部分传递)

第二大类是深度学习模型，如果采用深度学习的一些model，这是需要将model file算出来的item embedding的向量也需要离线存入KV中，但是用户在访问我们的KV的时候，在线访问深度学习模型服务（recall server）的User embedding。同时去将user embedding层的向量和item embedding层的向量做最近邻计算，并得到召回。

### 第02部分 个性化召回算法协同过滤理论部分

本章节主要讲解itemcf与usercf的基础理论部分与理论公式升级部分，并详细介绍itemcf与usercf的优缺点分析

#### **Item Collaborative Filtering**(Item CF)

背景

- 信息过载，用户需求不明确
- 强依赖于用户行为

工业界主流落地场景

- 信息流
- 电商
- o2oLBS

含义：给用户推荐他之前喜欢的物品相似的物品

如何衡量相似

- 基于用户行为，如果喜欢2个物品的用户重合度越高，那么2个物品也就越相似。

如何衡量喜欢

- 看用户是否真实点击，在电商场景下，更看重实际转化（实际消费购买）；信息流场景下，更看重真实的点击（基于一定时长下的停留）

[![1563200876660](https://cdn.jsdelivr.net/gh/Shadowalker1995/images/2020/1563200876660.png)](https://enfangzhong.github.io/2019/06/01/个性化推荐算法实践第01章个性化推荐算法综述/1563200876660.png)

- 物品之间相似度公式：

$s_{i j}=\frac{|u(i) \cap u(j)|}{\sqrt{|u(i)| \cup|u(j)|}}$

u(i)表示喜欢物品i的用户数，$|u(i) \cap u(j)|$表示同时喜欢物品i和物品j的用户数

根据用户行为计算出用户相似度矩阵：

- 分子：u(i)表示对item (i)有过行为的用户集合 ,u(j)表示对item (j)有过行为的用户集合 ，分子表示user的重合程度，重合度越高，越相似。
- 分母：归一化（举例：对item(i)有过行为的用户2个，对item(j)有过行为的用户3个$\sqrt{2} \sqrt{3}=\sqrt{6}$,物理意义：惩罚的热门物品与其他物品的相似度，因为热门物品对应的user倒排会非常长造成了与很多物品都有重合，如果分母除以一个很大的数，将相似度的数值趋于0。

- 用户u对物品j的兴趣公式：

$p_{u j}=\sum_{i \in N(u) \cap s(j, k)} s_{i j} * r_{u i}$

N(u) 表示用户喜欢的物品集合，$s(j, k) $表示和物品j最相似的k个物品的集合。$s_{ij}$表示物品i和j的相似度.

表示用户u对物品i的兴趣。

$r_{ui}$表示user对 i的行为得分，$s_{ij}$表示物品的相似度得分

$p_{uj}$对user进行item(j)的推荐，根据item(i)来完成推荐的，item(i)是user行为过的物品并且取与item(i)最相似的top k个(一般50个），

Item CF在工业界落地公式升级1：

理论意义：针对于活跃用户应该被降低在相似度公式中的贡献度。

如果在某电商系统中，如果某User A是批发商，他购买了很多物品，可能有啤酒，书刊等，这都不能真实的表现他的兴趣。还有一名User B,他只买了啤酒和书刊，这能完全表现他的兴趣。如果我们在计算啤酒和书刊的相似度的时候，如果按照之前相似度公式User A和User B对啤酒和书刊的相似度贡献是一样的。这样子显然是不合理的。我们需要降低User A在相似度计算过程中的贡献度。

$s_{i j}=\frac{\sum_{u \in u(i) \cap u(j)} \frac{1}{\log (1+|N(u)|)}}{\sqrt{|u(i)||u(j)|}}$

u(i)表示喜欢物品i的用户数，$|u(i) \cap u(j)|$表示同时喜欢物品i和物品j的用户数

与之前的相似度计算公式公式相比，分母部门没有发生任何变化。那么我们重点看分子部分。之前的相似度计算公式中每个重合用户对相似度的贡献是一样的，都是1.但是升级后的公式，我们发现每个用户对相似度的贡献变成了不一样。N(u)表示用户u所行为过的item的总数。如果一个用户行为过的item的总数越多，那么他的相似度就越低。这样子是符合常理的认知的。

分子：N(u)表示用户u所行为过的item总数，如果用户行为过的总数越多，对相似度贡献越低。

Item CF在工业界落地公式升级2：

理论意义：用户在不同时间对item的操作应给予时间衰减惩罚。

因为在很多场景中，用户的兴趣随时间是有变化的。如在信息流场景中，可能30前看过的短视频，30天后就不一定喜欢了。因为在做物品相似度矩阵计算的时候，就假定了用户的行为可以反映用户的兴趣。所以需要给予时间衰减降权。

$s_{i j}=\frac{\sum_{u \in u(i) \cap u(j)} {f(\Delta t)}}{\sqrt{|u(i)||u(j)|}}$

$f(\Delta t)=\frac{1}{1+\alpha \Delta t}$的物理意义就是说如果item i与item j被行为时间的差异越小，那么就越逼近于1.如果他们item i与item j被行为时间的差异越大，那么这个贡献就越低。

与之前的相似度计算公式相比，分母部门没有发生任何变化。那么我们重点看分子部分。每个用户对相似度的贡献也发生了变化。这里的变化主要由$\Delta t$决定的。$\Delta t$是指用户item i与 item j所行为的时间的差异。

#### **User Collaborative Filtering**(User CF)

意义：给用户推荐相似兴趣用户感兴趣的物品。

举个栗子：在我们读书的时候是否经常问学长学姐该读什么样的书或者下载什么样的论文？学长学姐就会给你推荐。在这个栗子中学长学姐和你就属于具有相同爱好的用户群体，因为你们具有相同的研究领域。

那么所以基于用户的协同过滤的算法有两个步骤：

1、找到相似兴趣用户的集合

那么问题来了，如何评价相似兴趣用户集合？区别于很多传统做法，这里主要采用基于用户行为重合度的方法，举例来说，如果两个用户的行为具有很高的重合度，那么他们具有很高的相似性。那么他们可以称为相似兴趣用户集合。

2、推荐相似用户行为过，而该用户并没有行为过的item。举个栗子，如果我们发现两个用户A、B都非常喜欢足球相关的视频，行为重合度极高。而用户B经常点击天下足球相关的视频，用户A并没有行为，那么我们可以推荐天下足球相关的视频给用户A。

栗子：

[![1563200935981](https://cdn.jsdelivr.net/gh/Shadowalker1995/images/2020/1563200935981.png)](https://enfangzhong.github.io/2019/06/01/个性化推荐算法实践第01章个性化推荐算法综述/1563200935981.png)

User A 可以给User D 推荐b

基于用户的协同过滤算法的步骤

1、计算相似用户的相似度矩阵

相似度公式

$s_{u v}=\frac{|N(u) \cap N(v)|}{\sqrt{|N(u) | N(v)|}}$

N(u)表示用户u有过行为item的集合。N(v)表示用户v有过行为item的集合。

分子是item的重合程度。显然重合程度越高，user越相似。

分母做了一个归一化，物理意义上解释了惩罚了操作过多的用户与其他用户的相似程度。因为操作过多的用户对应的item的序列会非常的长，造成了与很多的用户都有相似。分母除以一个很大的数之后呢，就能把相似度得分的数值趋于0.在得到用户相似度矩阵过后，我们根据用户的行为点击，来完成相似用户的item推荐。

下面来看公式

$p_{u i}=\sum_{v \in s(u, k) \cap u(i)} S_{u v} {r}_{v i}$

${r}_{v i}$表示用户v对item i的行为得分。在前面介绍item cf公式的时候，我们提到过对于不同的行为，我们对用户的行为得分定义不同。我们这里将行为得分归一化为1.

$S_{u v} $表示user u与uer v的相似度得分。这里根据用户v来完成对用户u的推荐。所以这里要介绍用户v。用户v是用户u的前TOP k个的相似用户。并且用户v行为过的物品 item i,用户user u 没有行为。那么我们便得到了用户u对item i的推荐度得分。

工业界落地时公式升级1:

理论意义：降低那些异常活跃物品对与用户相似度的贡献

举个栗子解释：

如果某个电商系统中，User (A) 与User(B)同时购买了《新华字典》，User (A) 与User(C)同时购买了《机器学习》，并且他们都只有这一本书重合，User (A) 与User(B)、User (A) 与User(C)的重合度都是1，显然不合理，因为购买《新华字典》并不能十分准确的反映用户的兴趣，也许是给家里孩子买，换言之《新华字典》的用户倒排会非常的长，而购买《机器学习》的用户大概率可以反映他们的兴趣，因为这本书的购书群体很窄，因此我们需要降低那些很多人购买的在重合度中的贡献。

$s_{u v}=\frac{\sum_{i \in N(u) \cap N(v)} \frac{1}{\log (1+|u(i)|)}}{\sqrt{|N(u)||N(v)|}}$

分子：基础版本的相似度计算公式当中重合的每一item对整体的贡献都是相同的。在升级版中贡献变得不同的。u(i)表示对item(i)有过行为的用户集合，如果一个item被更多的用户行为过，那么它在重合度的贡献越低。这也符合我们的认知。

公式升级2（工业界）
理论意义，不同用户对同一item行为的时间段不同应该给予时间惩罚
（因为很多用户不同时间段，兴趣是发生变化的，比如，2个用户都曾经点击过足球类短视频，一个用户是近期点击，另一个用户是在好几个月之前欧洲杯比赛期间，也许在目前时间节点，已经不再喜欢足球类短视频了，我们在计算用户相似度矩阵的时候，假定了用户行为可以反映出用户的兴趣，所以我们要给予时间衰减降权）

$s_{u v}=\frac{\sum_{i \in N(u) \cap N(v)} f\left(\Delta t_{i}\right)}{\sqrt{|N(u) | N(v)|}}$

$f\left(\Delta t_{i}\right)=\frac{1}{1+\alpha\left|t_{u i}-t_{v i}\right|}$

与基础版本的用户相似度矩阵计算公式，分母没有发生任何变化。

分子：每一个重合的item的贡献度得分都变得不同,它们的贡献度得分由函数$f\left(\Delta t_{i}\right)$决定。函数$f\left(\Delta t_{i}\right)$具体的得分是2个用户对同一item操作时间的差，如果$\left|t_{u i}-t_{v i}\right|$越短的话,$f\left(\Delta t_{i}\right)$的得分越高;如果$\left|t_{u i}-t_{v i}\right|$越长的话,$f\left(\Delta t_{i}\right)$的得分越低。相应的在重合度贡献中也就越低。

#### Itemcf VS Usercf

优缺点比较：

推荐实时性

- User cf用户有了新的行为，不会对结果造成很快的变化，因为User cf是基于相似度矩阵来完成推荐的，User本身的行为并不能造成自己的推荐结果发生改变。
- Item cf用户一旦有了新的行为，推荐结果立刻发生改变，因为Item cf是基于相似度矩阵来完成推荐的，所以点击了物品，会立马推荐出相似的物品。

新用户/新物品的推荐

- User cf新用户的到来是不能立即推荐的，需要等用户有了一定的行为并且得到了与其他用户相似度矩阵之后才可以完成推荐，新用户一旦被用户点击，User cf可以通过相似度用户矩阵将该物品推荐给相似的用户。
- Item cf新用户一旦完成了Item点击，便可以推荐该Item相似的其余Item，新物品的到来，由于此时新物品 并没有与其他物品在相似度矩阵中出现，所以Item cf并不能将新物品及时地推荐出去。

推荐理由的可解释性

- User cf由于是通过用户相似度矩阵来完成推荐的，结果会略显难以解释。
- Item cf通过用户历史点击行为完成的推荐，所以推荐结果更加令人信服。

Item cf VS User cf适用场景
性能层面考量

- User cf通过计算用户相似度矩阵，所以它并不适合用户很多的场合。因为相似度矩阵计算起来代价非常大。
- Item cf需要计算物品的相似度矩阵，所以Item cf适用于物品数远小于用户数场合。由于实战中用户量往往远大于物品的数量级，所以实战中更倾向于Item cf。

个性化层面考量

- User cf适用于物品及时推荐下发且个性化需求不太强烈的领域。
- Item cf适用于长尾物品丰富并且个性化需要强烈的领域。由于真实的推荐系统中，各种个性化召回算法组合，会有一些召回方法解决新物品及时下发问题，而我们需要个性化程度强烈，所以从个性化层面考虑，更倾向于在落地实战中采用Item cf。

ItemCF的优势：

（1）计算性能高，通常用户数量远大于物品数量。

（2）可预先计算保留，物品并不善变。

ItemCF存在的问题：
物品冷启动问题：当平台中物品数据较少或缺失时，无法精确计算物品相似度，解决办法：

（1）文本分析，通过分析物品的介绍文本，计算相似度。
（2）主题模型，通过主题模型分析物品文本主题得出主题相似度。
（3）打标签，对物品打标签求得相似度。
（4）推荐排行榜单。

### 第03部分 个性化召回算法协同过滤代码实战部分

本章节结合具体的示例数据介绍itemcf与usercf基础部分的代码实战与升级部分的代码实战

#### 3-1 数据集介绍与公共信息抽取函数代码实战

本次代码实战的使用的2个数据集

rating.txt 用户对item的打分文件

> userId
>
> movieId
>
> rating: userId对movieId的打分
>
> timestamp：userId对movieId行为的时间戳

movies.txt item的info文件

> movidId
>
> title:item的标题
>
> genres:item的分类

在item CF和 User CF实战当中我们都需要得到user的点击序列，所以我们下面写一下公共的信息抽取函数。

本文使用PyCharm为代码编写平台。

1、数据集准备：

本实例使用MovieLens 数据集（下载地址：http://files.grouplens.org/datasets/movielens/ml-latest-small.zip中的ratings.csv（用户ID对电影ID的评分）以及movies.csv（电影类别明细）。如下：

[![1563266020865](/home/zzhenry/Boostnote/个性化推荐算法实践/第01章-个性化推荐算法综述.assets/1563266020865.png)](https://enfangzhong.github.io/2019/06/01/个性化推荐算法实践第01章个性化推荐算法综述/1563266020865.png)

[![1563266060785](/home/zzhenry/Boostnote/个性化推荐算法实践/第01章-个性化推荐算法综述.assets/1563266060785.png)](https://enfangzhong.github.io/2019/06/01/个性化推荐算法实践第01章个性化推荐算法综述/1563266060785.png)

 ratings.csv movies.csv

2、项目结构

[![1563266157632](/home/zzhenry/Boostnote/个性化推荐算法实践/第01章-个性化推荐算法综述.assets/1563266157632.png)](https://enfangzhong.github.io/2019/06/01/个性化推荐算法实践第01章个性化推荐算法综述/1563266157632.png)

data文件夹用于存储电影评分数据，production文件夹用于存放推荐代码，util文件夹用于存放用于读取数据的工具文件。

3、reader.py：用于读取用户的点击序列（即每个用户对那些电影进行过评分）以及电影信息（id，名称，类别）。

复制

```
# _*_ encoding: utf-8 _*_
'''
@File    :   reader.py    
@Contact :   anfrank@gmail.com
@License :   (C)Copyright 2019-2020

@Modify Time      @Author    @Version    @Desciption
------------      -------    --------    -----------
2019/7/16 13:38   anfrank      1.0          None
'''
# import lib
import os


# 获得用户的点击序列
def get_user_click(rating_file):
    '''
        get user click list[userid,itemid]
        :param rating_file:input file
        :return:输出是一个dict key:userid value:[itemid1,itemid2]
    '''
    # 如果路径不存在，返回空数据
    if not os.path.exists(rating_file):
        return {}
    # 打开文件
    fp = open(rating_file)
    num = 0
    # 用于传回的数据
    user_click = {}
    # 循环数据
    for line in fp:
        # 第一行是表头，需要跳过处理
        if num == 0:
            num += 1
            continue
        # 根据逗号提取每个项目
        item = line.strip().split(',')
        # print(item)

        if len(item) < 4:
            continue
        [userid, itemid, rating, timestamp] = item

        if float(rating) < 3.0:  # 如果评分低于3分，则视为该用户不喜欢该电影
            continue
        # 将单一用户的点击序列添加至返回数据
        if userid not in user_click:
            user_click[userid] = []
        user_click[userid].append(itemid)
    fp.close()
    return user_click


# 获取电影信息数据
def get_item_info(item_file):
    '''
    get item info[title,genres]
    :param item_file: input iteminfo file
    :return: a dict,key itemid,value:[title,genres]
    '''
    # 若路径不存在则返回空
    if not os.path.exists(item_file):
        return {}
    num = 0
    item_info = {}
    # fp = open(item_file, 'r', encoding='UTF-8')
    fp = open(item_file,'r',encoding='UTF-8')
    for line in fp:
        # 第一行是表头，需要跳过处理
        if num == 0:
            num += 1
            continue
        # 根据逗号提取每个项目
        item = line.strip().split(',')
        if len(item) < 3:  # 若单行小于三项过滤（去除问题行）
            continue

        if len(item) == 3:
            [itemid, title, genres] = item
        # 这个elif语句是由于，有的电影名称中含有逗号，因此造成项数过多，需要另行处理
        elif len(item) > 3:
            itemid = item[0]
            genres = item[-1]  # 获取最后一项
            title = ",".join(item[1:-1])  # 第一个到最后一个的拼接成为电影名称
        # 将电影信息数据返回
        if itemid not in item_info:
            item_info[itemid] = [title, genres]
    fp.close()
    return item_info


# 测试上述方法
if __name__ == '__main__':

    # f = open("../data/ml-1m/ratings.dat")
    user_click = get_user_click("../data/ml-latest-small/ratings.csv")
    print("输出user_click字典的用户数量：")
    print(len(user_click))
    print("输出user_click字典的key为1点击了的item：")
    print(user_click['1'])

    item_info = get_item_info("../data/ml-latest-small/movies.csv")
    print("输出item_info字典的item数量：")
    print(len(item_info))
    print("输出item_info字典的key为1的item名称")
    print(item_info['1'])
```

#### 3-2 itemcf基础部分代码实战

三、参考资料
1、https://www.imooc.com/learn/1029

2、https://www.imooc.com/learn/990

3、https://study.163.com/course/introduction/1004092024.htm

4、https://blog.csdn.net/yimingsilence/article/details/54934302

5、https://blog.csdn.net/xiaokang123456kao/article/details/74735992

6、项亮. 推荐系统实践[M]. 人民邮电出版社, 2012.

### 第04部分 个性化推荐召回算法的离线在线评估方法

从离线在线两个方面，带大家详细了解如何评估个性化推荐算法对个性化推荐系统的影响。

#### 1、业务指标

信息流更关注：

- 点击率：总点击次数/总展现次数

- 平均阅读时长（两个小指标）：

     推荐精准度：总阅读时长/click uv

     推荐算法对整体趋势的影响：阅读总时长/show uv

电商推荐中更关注转化率：

- 转化率：总得成交次数/总的展现次数
- 还有总的成交额度（ GMV）

#### 2、 item推荐覆盖率

如果我们无休止的去剥削用得的点击历史，会发现推荐的item呈现长尾，很多item无法得到充分的展现。所以我们要利用一些发现算法保证item的覆盖率。

复制

```
覆盖率：去重后推荐的所有item的id数/库里面所有的itemid
```

如何在个性化召回算法中从离线和在线两个方面来评价算法的好坏呢？

#### 3、offline评价方法

复制

```
评测模型推荐结果在测试集上的表现
```

如果在推荐系统中，某种算法给用户A推荐的物品（a、b、d）。又得到，在测试集中，用户A有过物品a,b,f,m的展现。这个时候我们发现推荐出来的真实结果和测试上的结果重合为物品（a、b）。这个集合就是我们评价的分母。

我们又发现用户a在测试集上点击了物品（a、f）,那么推荐的真实物品结果（a、b、d）,与用户在测试集上点击（a、f）也有重合,重合的为a，这个重合就是他的分母。点击率：总点击次数/总展现次数。综上，整体的点击率表现为1/2。

[![1564489139051](https://cdn.jsdelivr.net/gh/Shadowalker1995/images/2020/1564489139051.png)](https://enfangzhong.github.io/2019/06/01/个性化推荐算法实践第01章个性化推荐算法综述/1564489139051.png)

#### 4、 online评价方法

复制

```
定义指标：
      信息流中：点击率、平均阅读时长、覆盖率

      生产环境中A/B test，分离出一部分流量对比
```

### 第05部分总结

推荐引擎主体架构，工业界推荐系统落地

- 推荐引擎主体架构主要分为match召回、Rank排序、以及strategy策略调整部分。并对Match在工业界的几种落地架构进行了深入剖析。对工业界电商、信息流、地图基于位置服务的（LBS）的推荐进行了详细介绍。

CF算法的落地实战

- item cf
- user cf
- item cf和user cf不同场景下的优劣对比
- 借助demo数据，实现itemCF与user CF

推荐系统在不同业务下的评价指标

- 分别从offline评价方法和online评价方法两个方面展示了，如何在新增一个召回算法来评价改算法的性能。

### 第06部分预习参考资料：

recall:矩阵分解、graph、content based 、item2vec(用DNN来将user和item分别embedding成隐语义向量做向量召回)

> [个性化推荐算法实践第01章个性化推荐算法综述]([https://enfangzhong.github.io/2019/06/01/%E4%B8%AA%E6%80%A7%E5%8C%96%E6%8E%A8%E8%8D%90%E7%AE%97%E6%B3%95%E5%AE%9E%E8%B7%B5%E7%AC%AC01%E7%AB%A0%E4%B8%AA%E6%80%A7%E5%8C%96%E6%8E%A8%E8%8D%90%E7%AE%97%E6%B3%95%E7%BB%BC%E8%BF%B0/](https://enfangzhong.github.io/2019/06/01/个性化推荐算法实践第01章个性化推荐算法综述/))
>
> [推荐系统系列之隐语义模型](https://www.jianshu.com/p/7b6bb28c1753)
>
> [【机器学习】—隐语义模型](https://www.cnblogs.com/LHWorldBlog/p/9170834.html)
>
> [DNN个性化推荐模型](https://www.cnblogs.com/rongyux/p/6864233.html)
>
> [DNN论文分享 - Item2vec: Neural Item Embedding for Collaborative Filtering](https://blog.csdn.net/kingzone_2008/article/details/81129717)
>
> [万物皆Embedding，从经典的word2vec到深度学习基本操作item2vec](https://www.jianshu.com/p/6c977a9a53de)