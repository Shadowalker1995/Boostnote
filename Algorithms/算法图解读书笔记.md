# 算法图解读书笔记

[toc]

## 1. 图书简介

> 书名:算法图解 - 像小说一样有趣的算法入门书
>
> 原著作者:[美] Aditya Bhargava
>
> 翻译:袁国忠
>
> ISBN:978-7-115-44763-0

简评: 初读感觉这本书太过浅显, 完全是为了零基础的人写的, 毫无阅读压力. 读到后面方才领悟, 原来这感觉只是因为作者功力深厚, 每个例子都恰到好处且深入浅出. 能把复杂枯燥的算法写得如此通俗, 难怪此书能成为经典. 不到一周的时间读完了整本书, 我却获益匪浅, 回味无穷啊!

原书使用的是 Python 2 演示的算法代码.在这系列笔记里面, 我全都转换成了 Python 3 的代码. 对于作者有些我觉得不合适的地方, 稍作修改.有些大的修改我做了解释, 小改动则一般什么也没说.

## 2. 二分查找

> 一个快速搜索定位到有序数组中元素位置的检索方法. 道理很简单, 也很有用.

二分査找是一种算法, 其输入是一个有序的元素列表 (必须有序的原因稍后解释). 如果要査找的元素包含在列表中, 二分査找返回其位置, 否则返回 `null`.

通过实例了解二分查找:

有一个数字, 处在 1 - 100 之间. 如何通过最少的次数猜到这个数字? 当每次猜测后, 会告诉你猜测的值是大了, 小了, 还是刚好猜中.

<img src="%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/1582179780099.png" alt="img" style="zoom:50%;" />

我们当然可以从 1 开始, 逐个猜测, 但显然, 这是相当耗时的. 这种方法被称为简单查找, 或者更准确来讲, 是傻找. 如果这个数字是 100, 需要猜 100 次才能找到!

<img src="%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/1582179890908.png" alt="img" style="zoom:50%;" />

更好的方式是从给定范围的中间位置开始猜. 上面这里个例子就是 100/2 = 50. 如果我们得知, 猜的数字小了.虽然没有直接得到想要的结果, 但是一次性就排除了一半的可能. 这样每次排除一半, 很快就能找到结果了.

<img src="%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/1582180058952.png" alt="img" style="zoom: 67%;" /><img src="%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/1582180080678.png" alt="img" style="zoom: 33%;" /><img src="%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/1582180090959.png" alt="img" style="zoom: 50%;" />

不管这个数字是什么, 我们总会在 7 次之内找到答案, 因为每次猜测都能排除很多数字.

![img](%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/1582180155465.png)

假设你要在字典中查找一个单词, 而该字典包含 240000 个单词, 你认为每种查找最多需要多少步?

使用简单查找最多要 240000 步, 而使用二分查找, 最多只需要 17 步.

![img](%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/1582180545528.png)

一般而言, 对于包含 $n$ 个元素的列表, 用二分査找最多需要 $log_2(n)+1$ 向下取整步, 而简单查找最多需要 $n$ 步.

用代码表示二分算法:

```python
def binary_search(ordered_list: list, item: int):
    low = 0    # low 和 high 用来记录未被检索到的列表范围
    high = len(ordered_list) - 1
    while low <= high:    # 只要范围内还有元素
        mid = (low + high) // 2   # 找到中间的元素去检查
        guess = ordered_list[mid]
        if guess == item:    # 刚好猜中, 把值返回
            return mid
        elif guess > item:    # 猜的数字大了
            high = mid - 1   # 修改范围, 因为 mid 已经猜过, 可以排除
        else:               # 猜的数字小了
            low = mid + 1
    return None        # 若没有找到元素, 返回 None

test_list = [1, 3, 5, 7, 9]

print(binary_search(test_list, 3))    # 1 --- 返回的是 3 的索引
print(binary_search(test_list, -1))   # None --- 没有找到
```

## 3. 大 O 表示法

> 一个算法中极重要的概念, 用来表示一个算法消耗时间的状况.

### 3.1 大 $O$ 表示法的概念

大 $O$ 表示法指出了算法有多快. 例如, 假设列表包含 $n$ 个元素.简单査找需要检查每个元素, 因此需要执行 $n$ 次操作.使用大 $O$ 表示法, 这个运行时间为 $O(n)$. 单位秒呢? 没有——大 $O$ 表示法指的并非以秒为单位的速度. 大 $O$ 表示法让你能够比较操作数, 它指出了算法运行时间的**增速**.

同样地, 为检查长度为 $n$ 的列表, 二分查找需要执行 $log_2(n)$ 次操作. 使用大 $O$ 表示法, 这个运行时间可以用 $O(log\ n)$ 表示一般而言大 $O$ 表示法像下面这样. 之所以称为大 $O$ 表示法, 是因为操作数前有个大 $O$.

![img](%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/1582183152573.png)

大 $O$ 表示法表示的是最糟情况下的运行时间.当然, 除了最糟情况, 有时也会考虑平均情况.

一些常见的大 $O$ 运行时间如下:

- $O(log\ n)$, 也叫对数时间, 这样的算法比如: 二分查找
- $O(n)$, 也叫线性时间, 比如简单查找
- $O(n∗log\ n)$, 比如快速排序 —— 一种速度较快的排序算法
- $O(n^2)$, 比如选择排序 —— 一种速度较慢的排序算法
- $O(n!)$, 比如旅行商问题的解决方案 —— 一种非常慢的算法
- $O(1)$, 常量时间, 不意味着马上, 而是意味着无论数据量多大, 所需时间都是相同的

<img src="%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/1582185043657.png" alt="img" style="zoom:67%;" />

上述图表中的时间是基于每秒执行 10 次操作计算得到的. 这些数据并不准确, 这里提供它们只是想让你对这些运行时间的差别有大致认识. 实际上, 计算机每秒执行的操作远不止 10 次.

还有其他的运行时间, 但这五种是最常见的.

小结如下:

- 算法的速度指的并非时间, 而是操作数的增速.
- 谈论算法的速度时, 我们说的是随着输入的增加, 其运行时间将以什么样的速度增加.
- 算法的运行时间用大 $O$ 表示法表示.
- $O(log\ n)$ 比 $O(n)$ 快, 当需要搜索的元素越多时, 前者比后者快得越多.

### 3.2 排序算法的运行时间

选择排序的运行时间为 $O(n^2)$, 速度非常慢. 合并排序 (merge sort) 的排序算法运行时间为 $O(n log\ n)$, 比选择排序快得多! 快速排序的情况比较棘手, 在最糟情况下, 其运行时间为 $O(n^2)$ 与选择排序一样慢! 但这是最糟情况. 在平均情况下, 快速排序的运行时间为 $O(n log\ n)$.

你可能会有如下疑问: 这里说的最糟情况和平均情况是什么意思呢? 若快速排序在平均情况下的运行时间为 $O(n log\ n)$, 而合并排序的运行时间总是 $O(n log\ n)$, 为何不使用合并排序? 它不是更快吗?

来看下面两个打印列表中元素的简单函数:

```python
def print_items(arr: list):
    for i in arr:
        print(i)

print_items([2, 4, 6, 8, 10])
```

这个函数遍历列表中的每个元素并将其打印出来. 它迭代整个列表一次, 因此运行时间为 $O(n)$. 现在我们对这个函数进行修改, 使其在打印每个元素前都休眠 1 秒钟:

```python
import time

def print_items2(arr: list):
    for i in arr:
        time.sleep(1)
        print(i)

print_items2([2, 4, 6, 8, 10])
```

这个函数每次打印元素前都要休眠 1 秒.

<img src="%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/1582279780670.png" alt="img" style="zoom:67%;" />

这两个函数的时间都是 $O(n)$, 但是很明显, 第一个函数运行速度要快很多. 这是因为, 事实上, 我们使用大 $O$ 表示法表示时间时, $n$ 的含义是有一个常数系数的.

<img src="%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/1582279949871.png" alt="img" style="zoom:67%;" />

$C$ 是算法所需的固定时间量, 被称为常量. 例如, `print_items` 所需的时间可能是 10 毫秒 $*\ n$, 而 `print_items2` 所需的时间为 1 秒 $*\ n$.

通常不考虑这个常量, 是因为对于时间复杂度不同的算法而言, 当数据量很大时, 这个常熟造成的影响微乎其微.

比如假设时间复杂度为 $O(n)$ 的简单查找的时间常数为 10 毫秒, 时间复杂度为 $O(log\ n)$ 的二分查找时间常数为 1 秒.

![img](%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/1582280228579.png)

那么如果在含有 40 亿个数据中查找数据的话, 两种方法所需时间为:

![img](%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/1582280265916.png)

二分查找依然快很多, 即便他的常量是简单查找的 100 倍.

但有时候, 常量的影响可能很大, 对快速査找和合并査找来说就是如此. 快速査找的常量比合并查找小, 因此即便它们的运行时间都为 $O(n log\ n)$, 快速査找的速度仍有可能会更快. 实际上, 快速査找的速度确实更快 —— 因为相对于遇上最糟情况, 它遇上平均情况的可能性要大得多.

### 3.3 平均情况和最糟情况

快速排序的性能髙度依赖于你选择的基准值. 假设你总是将第一个元素用作基准值, 且要处理的数组是有序的. 由于快速排序算法不检查输入数组是否有序, 因此它依然尝试对其进行排序.

<img src="%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/1582280577466.png" alt="img" style="zoom:50%;" />

注意, 数组并没有被分成两半, 相反, 其中一个子数组始终为空, 这导致调用栈非常长.

现在假设你总是将中间的元素用作基准值, 在这种情况下, 调用栈如下.

<img src="%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/1582280624165.png" alt="img" style="zoom:50%;" />

调用栈短得多! 因为每次都将数组分成两半, 所以不需要那么多递归调用. 你很快就到达了基线条件, 因此调用栈短得多.
第一个示例展示的是最糟情况, 而第二个示例展示的是最佳情况. 在最糟情况下, 栈长为 $O(n)$, 而在最佳情况下, 栈长为 $O(n log\ n)$.现在来看看栈的第一层.你将一个元素用作基准值, 并将其他的元素划分到两个子数组中.这涉及数组中的全部 8 个元素, 因此该操作的时间为 $O(n)$. 在调用栈的第一层, 涉及全部 8 个元素, 但实际上, 在调用栈的每层都涉及 $O(n)$ 个元素.

<img src="%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/1582280845892.png" alt="img" style="zoom:50%;" />

对于最佳情况, 每次也是涉及 $O(n)$ 个元素.

<img src="%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/1582280882446.png" alt="img" style="zoom:50%;" />

因此, 完成每层的任务, 所需要的时间都为 $O(n)$.

<img src="%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/1582280961804.png" alt="img" style="zoom:50%;" />

对于最理想情况, 总层数为 $O(log\ n)$ (用技术术语来讲, 就是调用栈的高度为 $O(log\ n)$) .又因为每一层需要的时间为 $O(n)$, 所以整个算法所需要的总时间为 $O(n) ∗ O(log\ n)=O(n log\ n)$.

对于最糟情况, 有 $O(n)$ 层, 于是算法的运行时间为 $O(n) ∗ O(n)$.

知道吗? 这里要告诉你的是, 最佳情况也是平均情况. 只要你每次都随机地选择一个数组元素作为基准值, 快速排序的平均运行时间就将为 $O(n log\ n)$. 快速排序是最快的排序算法之一, 也是 D&C 的典范.

小结:

1. 实现快速排序时, 请随机地选择用作基准值的元素. 快速排序的平均运行时间为 $O(n log\ n)$
2. 大 $O$ 表示法中的常量有时候事关重大, 这就是快速排序比合并排序快的原因所在
3. 比较简单査找和二分查找时, 常量几乎无关紧要.因为列表很长时,  $O(log\ n)$ 的速度比 $O(n)$ 快得多

## 4. 旅行商问题简述

> 这是一个困扰数学家很久的问题.旅行家问题的时间复杂度为 $O(n!)$, 是一个极其耗时的算法. 优化旅行家问题很有用, 但却一直没有好办法.

旅行商问题 (Traveling Salesman Problem, TSP), 是一个时间复杂度极高的算法问题. 解决起来非常棘手.

有一位旅行商, 要前往五个城市.

<img src="%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/1582185632337.png" alt="img" style="zoom:50%;" />

为了确保他的旅程距离最短, 需要列出所有可能的路线.

<img src="%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/1582185693628.png" alt="img" style="zoom:50%;" />

对于每种顺序, 他都要计算总旅程, 再挑选岀旅程最短的路线. 5 个城市有 120 种不同的排列方式. 因此, 在涉及 5 个城市时, 解决这个问题需要执行 $A_5^5=5!=120$ 次操作. 涉及 6 个城市时, 需要执行 $6!=720$ 次操作. 涉及 7 个城市时, 需要执行 5040 次操作.

<img src="%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/1582185838313.png" alt="img" style="zoom:50%;" />

推而广之, 涉及 $n$ 个城市时, 需要执行 $n!$ ($n$ 的阶乘) 次操作才能计算出结果.因此运行时间为 $O(n!)$, 即阶乘时间. 除非涉及的城市数很少, 否则需要执行非常多的操作. 如果涉及的城市数超过 100, 根本就不能在合理的时间内计算出结果 —— 等你计算出结果, 太阳都没了.

这种算法很糟糕, 却别无选择. 这是计算机科学领域待解的问题之一. 对于这个问题, 目前还没有找到更快的算法有些很聪明的人认为这个问题根本就没有更巧妙的算法.面对这个题, 我们能做的只是去找出近似答案.

## 5. 数组和链表

> 两种计算机内部存储数据的方式, 各有优缺点.

- 数组
    - 在内存中连续存储
    - 同一个数组中, 所有元素类型必须相同 (都为 `int`、``double` 等) 
    - 使用不灵活, 若在中间插入数据, 需要先把该位置以后的元素全部后移, 删除数据同理
    - 若当前位置剩余的空间不能容纳插入后的列表, 整个列表需要重新在内存中找一块空间, 整体转移
    - 可以通过预留空间的方式减缓上述问题, 但不可避免, 且预留空间会造成空间占用过多的问题
    - 查找元素效率高, 直到起始位置和元素索引, 通过简单计算即可确定所需数据的内存地址

<img src="%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/1582186861558-166746149887823.png" alt="img" style="zoom:50%;" />

- 链表

    - 在内存中不必连续, 前一个元素会记录下一个元素的内存地址

    <img src="%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/1582186896705.png" alt="img" style="zoom:50%;" />

    - 使用灵活, 随意增删数据.增加数据只需让前一个数据记录这个数据内存地址, 然后这个数据记录到下一个数据的内存地址即可. 删除数据只需让前一个数据记录的内存地址改为下一个数据的内存地址即可
    - 不会因预留空间而浪费内存
    - 查找元素效率低, 需要从第一个开始, 逐次查找

常见的数组和链表操作的运行时间如下:

| 操作 | 数组   | 链表   |
| ---- | ------ | ------ |
| 读取 | $O(1)$ | $O(n)$ |
| 插入 | $O(n)$ | $O(1)$ |
| 删除 | $O(n)$ | $O(1)$ |

其中, $O(1)$ 为常量时间, $O(n)$ 为线性时间.

需要指出的是, 仅当能够立即访问要删除的元素时, 删除操作的运行时间才为 $O(1)$. 通常我们都记录了链表的第一个元素和最后一个元素, 因此删除这些元素时运行时间为 O(1).

数组和链表哪个用得更多呢? 显然要看情况.但数组用得很多, 因为它支持随机访问. 有两种访问方式: 随机访问和顺序访问. 顺序访问意味着从第一个元素开始逐个地读取元素, 链表只能顺序访问: 要读取链表的第十个元素, 得先读取前九个元素, 并沿链接找到第十个元素.随机访问意味着可直接跳到第十个元素. 本书经常说数组的读取速度更快, 这是因为它们支持随机访问.很多情况都要求能够随机访问, 因此数组用得很多. 数组和链表还被用来实现其他数据结构, 这将在本书后面介绍.

## 6. 选择排序

> 一种经典的排序方式, 先找出最大的数, 然后找出第二大的, 这样一个一个排列好.很容易理解, 但很慢.

要理解本节的内容, 你必须熟悉数组、链表和大 $O$ 表示法.

选择排序, 就是把列表中最大的元素放到新列表中并在原列表中删除. 然后在列表中剩下的元素里继续这样做, 找到第二大的元素.这样逐次选择查找, 最终完成排序的任务.

<img src="%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/1582188189847.png" alt="img" style="zoom:33%;" /><img src="%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/1582188197995.png" alt="img" style="zoom:33%;" /><img src="%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/1582188205709.png" alt="img" style="zoom:33%;" />

查找排序需要的时间为 $O(n^2)$.

<img src="%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/1582188286267.png" alt="img" style="zoom:33%;" />

选择排序的示例代码如下:

```python
from copy import deepcopy

def find_smallest(arr: list) -> int:
    """
    用于查找数组中最小值的索引
    :param arr: 目标数组
    :return: 最小值索引
    """
    smallest = arr[0]
    smallest_index = 0
    for i in range(1, len(arr)):
        if arr[i] < smallest:
            smallest = arr[i]
            smallest_index = i
    return smallest_index

def selection_sort(arr: list) -> list:
    """
    选择排序的主函数, 将一个数组升序排列返回
    :param arr: 目标数组
    :return: 升序排列好的数组
    """
    arr = deepcopy(arr)  # 因为后面要进行列表删除操作, 这样做是为了避免对原列表造成影响
    new_arr = []
    for i in range(len(arr)):  # 避免循环删除的坑
        smallest_index = find_smallest(arr)
        new_arr.append(arr.pop(smallest_index))  # 将本次最小的元素转移到新列表的最后
    return new_arr

print(selection_sort([5, 3, 6, 2, 10]))    # [2, 3, 5, 6, 10]
```

## 7. 递归

> 人理解函数, 神理解递归.递归是一个很巧妙的解题思路, 但是总是很绕.而一旦解决出问题, 又显得那么的优雅.可以说, 是一种高贵的算法吧.

有这样一个盒子, 盒子里面有很多小盒子. 小盒子里面可能还是装着盒子的盒子, 在这些盒子中, 有一个盒子会装着钥匙. 我们要怎么样把钥匙找出来呢?

<img src="%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/1582192271970.png" alt="img" style="zoom: 50%;" />

第一种方法使用下面这个流程:

1. 创建一个要查找的盒子堆；
2. 从盒子堆取出一个盒子, 在里面找；
3. 如果找到的是盒子, 就将其加入盒子堆中, 以便以后再査找；
4. 如果找到钥匙, 则大功告成!
5. 回到第二步.

<img src="%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/1582192352922.png" alt="img" style="zoom:50%;" />

也可以通过第二种方法这个流程:

1. 检查盒子中的每样东西；
2. 如果是盒子, 就回到第一步；
3. 如果是钥匙, 就大功告成.

如果用每一个列表代表着一个盒子, 那么上面的问题可以描述为, 如何从下面的列表中找到 `钥匙`:

```python
box = [[[[],[],[],[]],[[[],[],[]],[]],[]], [[],[[[],['钥匙']],[]],[],[[],[]]],[[],[],[[],[]]]]
```

如果是第一种方法, 我们可以用 whil 循环实现:

```python
from copy import deepcopy

def look_for_key(main_box: list):
    pile = deepcopy(main_box)    # 创建盒子堆
    while len(pile):    # 只要盒子堆里还有盒子, 就继续循环
        box = pile.pop()    # 从盒子堆里拿出一个盒子来
        for item in box:    # 打开盒子, 看看里面的东西都有啥
            if isinstance(item, list):    # 如果还是盒子
                pile.append(item)    # 就放到盒子堆里
            elif item == '钥匙':    # 如果是钥匙
                print('找到钥匙了!')    # 就成功了!
                return item    # 这个的作用是终止程序, 找到以后就不要继续找了

box = [[[[], [], [], []], [[[], [], []], []], []], [[], [[[], ['钥匙']], []], [], [[], []]], [[], [], [[], []]]]
look_for_key(box)
```

对于第二种方法, 我们可以通过函数自己调用自己的方式实现:

```python
def look_for_key(box: list):
    for item in box:    # 把盒子拆开, 看看每个东西都是啥
        if isinstance(item, list):    # 如果是盒子, 就继续打开
            look_for_key(item)    # 看看里面有没有钥匙
        elif item == '钥匙':    # 如果是钥匙
            print('找到钥匙了!')    # 大功告成
            break    # 不必继续找了

box = [[[[], [], [], []], [[[], [], []], []], []], [[], [[[], ['钥匙']], []], [], [[], []]], [[], [], [[], []]]]
look_for_key(box)
```

这两种方法的作用相同, 但在我看来, 第二种方法更清晰. 递归只是让解决方案更清晰, 并没有性能上的优势. 实际上, 在有些情况下, 使用循环的性能更好. 我很喜欢 Leigh Caldwell 在 Stack overflow 上说的一句话: “如果使用循环, 程序的性能可能更高; 如果使用递归, 程序可能更容易理解. 如何选择要看什么对你来说更重要.”

编写递归函数时, 必须告诉它何时停止递归. 正因为如此, 每个递归函数都有两部分: 基线条件 (base case) 和递归条件 (recursive case). 递归条件指的是函数调用自己, 而基线条件则指的是函数不再调用自己, 从而避免形成无限循环.

比如在下面的递归中:

```python
import time

def countdowm(i):
    print(i)
    if i <= 1:    # 基线条件
        return
    else:    # 递归条件
        time.sleep(1)
        countdowm(i - 1)

countdowm(5)
```

<img src="%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/1582193982186.png" alt="img" style="zoom:50%;" />

## 8. 栈

> 这里的栈更多的指的是调用栈, 是针对嵌套的函数而言的. 调用栈让理解递归更容易些.

本节将介绍一个重要的编程概念 — 调用栈 (call stack). 调用栈不仅对编程来说很重要, 使用递归时也必须理解这个概念.

栈是一种后进先出的数据结构, 只有压入和弹出两种操作:

<img src="%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/1582199656154.png" alt="img" style="zoom:50%;" />

### 8.1 调用栈

计算机在内部使用被称作调用栈的栈.

来看下面的函数调用:

```python
def greek(name):
    print('hello, ' + name + '!')
    greek2(name)
    print('getting ready to say bye...')
    bye()

def greek2(name):
    print('how are you, ' + name + '?')

def bye():
    print('ok bye!')

greek('maggie')
```

为简便起见, 下面的讨论先不把 print 看作函数了.

当我们调用 `greet('maggie')` 函数时, 计算机将首先为该函数调用分配一块内存. 我们来使用这些内存. 变量 name 被设置为 maggle, 这需要存储到内存

<img src="%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/1582202514345.png" alt="img" style="zoom:33%;" />

函数 greet 从上向下执行, 只要函数没有执行完, 内存就不会被释放. 最开始, 是打印出一串内容, `hello, maggie!`. 随后, 调用 greek2 函数, 参数 name 还是 maggie. 需要注意的是, 此时 greek 函数尚未执行完毕, 所以内存不会释放, 而因为调用了 greek2, 还要给它一块内存空间, 就放在 greek 空间的上面. 这种层叠的空间存储结构, 就是调用栈.

<img src="%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/1582202741681.png" alt="img" style="zoom:33%;" />

此时, greek 暂时被搁置, 活跃的是最上方的 greek2 函数.它从上往下执行, 打印出 `how are you, maggie?` 后, 运行完毕, 释放内存空间. 栈顶端的 greet2 占用的内存块被弹出.

<img src="%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/1582202855569.png" alt="img" style="zoom:33%;" />

此时, 活跃的函数又是 greek 了. 调用 greek2 的步骤已经执行完毕, 接着往下走, 打印出 `getting ready to say bye...` 之后, 又调用了 bye 函数. 同样道理, bye 函数的内存块被压倒栈的顶端.

<img src="%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/1582203287407.png" alt="img" style="zoom:33%;" />

bye 运行, 打印出 `ok bye!` 后, 释放内存空间, 从栈顶段弹出.

<img src="%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/1582203328339.png" alt="img" style="zoom:33%;" />

greet 的最后一行代码也执行完, 它也从栈中弹出. 这个栈用于存储多个函数的变量, 称为调用栈.

### 8.2 递归调用栈

递归函数也使用调用栈! 来看看递归函数 factorial 的调用栈.`factorial(5)` 写作 $5!$, 其定义如下: $5! = 5 * 4 * 3 * 2 * 1$. 同理, `factorial(3)` 为 $3 * 2 * 1$.下面是计算阶乘的递归函数:

```python
def fact(n: int):
    if n == 1:
        return n
    else:
        return n * fact(n - 1)

print(fact(5))    # 120
print(fact(3))    # 6
```

下面来详细分析调用 `fact(3)` 时调用栈是如何变化的. 别忘了, 栈顶的方框指出了当前执行到了什么地方.

<img src="%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/1582203865817.png" alt="img" style="zoom:50%;" />

注意, 每个 `fact` 调用都有自己的 `x` 变量. 在一个函数调用中不能访问其他函数的 `x` 变量.

递归调用栈包含未完成的函数调用, 每个函数调用都包含还未检查完的盒子. 使用栈很方便, 因为你无需自己跟踪盒子堆 —— 栈替你这样做了.

使用栈虽然很方便, 但是也要付出代价: 存储详尽的信息可能占用大量的内存. 每个函数调用都要占用一定的内存, 如果栈很高, 就意味着计算杋存储了大量函数调用的信息. 在这种情况下, 你有两种选择:

- 重新编写代码, 转而使用循环.
- 使用尾递归. 这是一个高级递归主题, 不在本书的讨论范围内. 另外, 并非所有的语言都支持尾递归.

## 9. 分而治之

> 是一种用递归解决问题的思考方式.

分而治之 (divide and conquer, D&C). 一种著名的递归式解决问题的方法. 这不是一个解决特定问题的算法, 而是一种解决问题的思路. 面对问题时, 不再束手无策, 而是会自问: “使用分而治之能解决吗?”

D&C 算法是递归的, 使用 D&C 解决问题的过程包括两个步骤:

1. 找出基线条件, 这个条件要尽可能简单
2. 不断将问题分解 (或者说缩小规模), 直到符合基线条件

举个例子, 假如你是农场主, 你有一块土地, 尺寸如下.

<img src="%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/1582261613923.png" alt="img" style="zoom:33%;" />

你要将这块地均匀地分成方块, 且分出的方块要尽可能大. 显然, 下面的分法都不符合要求.

<img src="%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/1582261625780.png" alt="img" style="zoom:33%;" />

首先, 找出基线条件. 最容易处理的情况是: 一条边的长度是另一条边的整数倍.

<img src="%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/1582261661346.png" alt="img" style="zoom:33%;" />

然后, 缩小问题的规模. 按照规定, 合适的小正方形的边长是长方形短边的约数. 那么我们其实就可以从原来的长方形中, 切掉边长为短边长的大正方形, 而对于剩余的小长方形来说, 在里面找到我们所需要的小正方形大小也是一样的.

<img src="%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/1582262172247.png" alt="img" style="zoom:33%;" />

采用同样方法, 继续切割, 继续裁掉大正方形, 得到小长方形.

<img src="%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/1582262223458.png" alt="img" style="zoom:33%;" />

<img src="%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/1582262240588.png" alt="img" style="zoom:33%;" />

<img src="%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/1582262253858.png" alt="img" style="zoom:33%;" />

最终达到了基线条件, 最终的土地就是这种满足基线条件的土地:

<img src="%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/1582262294977.jpg" alt="img" style="zoom:33%;" />

上面问题的本质, 就是求长和宽的最大公约数. 使用的算法, 就是著名的欧几里得辗转相除法.

这里重申一下 D&C 的工作原理:

1. 找出简单的基线条件
2. 确定如何缩小问题的规模, 使其符合基线条件

D&C 并非可用于解决问题的算法, 而是一种解决问题的思路. 我们再来看一个例子给定一个数字数组, 求这个数组里面所有数字的和.

用循环可以很容易地解决问题:

```python
def sum_array(arr: list):
    total = 0
    for i in arr:
        total += i
    return total

arr = [1, 2, 3, 4]
print(sum_array(arr))    # 10
```

不过这里我们要讨论的是分而治之的思想, 接下来, 我们看一看, 如何使用递归来实现数组元素求和.

第一步: 找出基线条件. 最简单的数组什么样呢? 如果数组不包含任何元素或只包含一个元素, 计算总和将非常容易, 这就是基线条件.

<img src="%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/1582265732269.png" alt="img" style="zoom: 50%;" />

第二步, 缩小问题的规模, 也即是如何让每次递归调用都更接近空的数组. 我们发现, 下面两个运算是等效的:

<img src="%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/1582265923542.png" alt="img" style="zoom: 33%;" />![img](%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/1582265928413.png)

也就是, 数组的总和等于第一个元素加上剩余元素的总和. 看起来似乎是废话, 但我们完成了关键的一步 —— 减少了数组长度, 使其更接近空数组. 这也就是我们的递归条件.

<img src="%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/1582266191979.png" alt="img" style="zoom: 50%;" />

整个算法的流程可以这样表示:

<img src="%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/1582266215680.png" alt="img" style="zoom:50%;" />

别忘了, 递归记录了我们之前函数的状态, 数据都储存在栈底端的函数中:

<img src="%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/1582266351165.png" alt="img" style="zoom:50%;" />

用代码实现上面的算法就是:

```python
def sum_array(arr: list) -> int:
    if len(arr) == 0:
        return 0
    elif len(arr) == 1:
        return arr.pop()
    else:
        return arr.pop() + sum_array(arr)

arr = [1, 2, 3, 4]
print(sum_array(arr))    # 10
```

练习题里面有一道, 很有趣, 也写出来. 题目是: 找出数组中最大的数字.

思路:

1. 基线条件: 一个数字, 返回当前元素; 空数组, 返回 0.
2. 递归条件: 取出数组中的一个数字, 将它同剩余数组中的最大值比较, 谁更大, 谁就是最大值.

```python
def get_max(arr: list) -> int:
    if len(arr) == 0:
        return 0
    elif len(arr) == 1:
        return arr.pop()
    else:
        num = arr.pop()
        max_num = get_max(arr)    # 这里一定要小心, 因为函数里涉及列表的删除, 要避免循环删除的坑
        return num if num > max_num else max_num

arr = [1, 2, 8, 9, 3, 4]
print(get_max(arr))    # 9
```

总结: D&C 将问题逐步分解. 使用 D&C 处理数组时, 基线条件很可能是空数组或只包含一个元素的数组.

## 10. 快速排序

> 一种速度比较快的排序算法, 应用的是分而治之思想.

快速排序是一种常用的排序算法, 比选择排序快得多. 例如, C 语言标准库中的函数 `qsort` 实现的就是快速排序. 快速排序也使用了 D&C.

对排序算法来说, 最简单的数组就是根本不需要排序的数组.

<img src="%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/1582267824209.png" alt="img" style="zoom:50%;" />

因此, 基线条件为数组为空或只包含一个元素. 在这种情况下, 只需原样返回数组 — 根本就不用排序. 用代码表示就是:

```python
def quick_sort(arr):
    if len(arr) < 2:
        return arr
```

对于两个元素的情况, 也很好办, 只需要将两个元素相比较即可:

![img](%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/1582268460524.png)

讨论三个和更多元素的情况, 就需要找到我们的递归条件, 把问题分解, 分而治之了.

首先来看只有三个元素的数组:

![img](%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/1582271122761.png)

我们从中任意取出一个元素作为基准值 (pivot) , 比如 33. 然后, 我们找到比这个基准值大的元素, 将其放在左边；比这个基准值小的元素, 放在右边:

![img](%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/1582271341610.png)

这被称为分区 (partitioning). 现在你有:

- 一个由所有小于基准值的数字组成的子数组
- 基准值
- 一个由所有大于基准值的数组组成的子数组

这里只是进行了分区, 得到的两个子数组是无序的. 但如果这两个数组已经排好序, 我们的任务便已经完成了.

好消息是, 含有两个元素的列表和空列表的排序方式刚刚我们已经找到了, 直接调用即可. 用代码表示就是:

```python
quick_sort([15, 10]) + [33] + quick_sort([])
```

不管使用哪个元素作为基准值都可以. 以 10 做基准值的情况和 33 做基准值道理相同. 若以 15 做基准值, 这个算法也是管用的.

![img](%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/1582271767672.png)

这个子数组都只有一个元素, 而你知道如何对这些数组进行排序.

现在你就知道如何对包含三个元素的数组进行排序了, 步骤如下:

1. 选择基准值
2. 将数组分成两个子数组:小于基准值的元素和大于基准值的元素
3. 对这两个子数组进行快速排序

同样道理, 对于有四个元素的数组排序, 已经不是什么麻烦事了.

<img src="%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/1582271904079.png" alt="img" style="zoom:50%;" />

比如还是以 33 作为基准值.

<img src="%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/1582271931382.png" alt="img" style="zoom:50%;" />

左边的元素有三个.而你已经直到如何给三个元素进行排序了:对其递归调用快速排序.

<img src="%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/1582272018894.png" alt="img" style="zoom:50%;" />

你已经直到如何对四个元素的列表进行排序. 那么你一定也知道如何对五个元素的列表进行排序了. 因为假设有下面这个数组.

<img src="%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/1582272071810.png" alt="img" style="zoom:50%;" />

你选的基准值和分区情况的可能性如下:

![img](%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/1582272096995.png)

注意, 这些子数组的数目都小于四.  而你已经知道如何对四个元素以下的数组进行排序了.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          子数组排序完成, 也意味着整个数组排序完成.

同理, 对于六个甚至更多元素的排序, 都可以这样一层一层地找到解决办法.

用代码表示快速排序算法就是:

```python
def quick_sort(arr: list) -> list:
    if len(arr) < 2:
        return arr    # 基线条件, 空列表和单元素列表天然“有序”
    else:
        pivot = arr.pop()    # 递归条件, 随意选择基准值
        less = []
        greater = []
        for i in arr:
            if i < pivot:
                less.append(i)    # 小于基准元素的值放到一块
            else:
                greater.append(i)    # 大于基准元素的值放到一块
        return quick_sort(less) + [pivot] + quick_sort(greater)

arr = [10, 5, 2, 3]
print(quick_sort(arr))
```

> 注: 原书给的方法中 less 和 greater 列表分别都是通过列表生成器实现的. 但是私以为, 这样会使用两个循环, 每次循环都要判断大小, 会造成重复相同操作的情况. 当然, 这样做的好处是代码更加简洁, 更易读. 不过为了效率期间, 我还是改成了直接使用循环生成列表的方式.

快速排序的运行时间问题, 请移步大 $O$ 表示法 .

## 11. 散列表 (哈希表)

> 虽然相较于简单查找而言, 二分查找能够节省大量的时间. 但随着数据量的增多, 查找的速度还是会变得很慢. 我们希望有一种数据结构, 查找数据时总能一下子就定位到我们要找的数据. 换句话说, 这种数据结构查找数据所需要的时间为 O (1). 数组和链表做不到这一点, 散列表可以做到.

查找无序数组或者链表中的数据, 我们只能从头往后逐个查找. 这种简单查找的方式需要消耗的时间为 $O(n)$. 而查找有序数组中的数据时, 我们可以通过二分查找, 快速定位到某个元素, 此时消耗的时间为 $O(log\ n)$.

虽然相较于简单查找而言, 二分查找能够节省大量的时间. 但随着数据量的增多, 查找的速度还是会变得很慢. 我们希望有一种数据结构, 查找数据时总能一下子就定位到我们要找的数据. 换句话说, 这种数据结构查找数据所需要的时间为 $O(1)$. 数组和链表做不到这一点, 散列表可以做到.

### 11. 散列函数

散列函数 (哈希函数) 是这样的函数, 即无论你给它什么数据, 它都还你一个数字.

<img src="%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/1584782713289.png" alt="img" style="zoom: 33%;" />

如果用专业术语来表达的话, 我们会说, 散列函数是将输入映射到数字. 你可能认为散列函数输出的数字没什么规律, 但其实散列函数必须满足一些要求:

- 它必须是一致的. 例如, 假设你输入 apple 时得到的是 4, 那么每次输入 apple 时, 得到的都必须为 4. 如果不是这样, 散列表将亳无用处
- 它应将不同的输入映射到不同的数字. 例如, 如果一个散列函数不管输入是什么都返回 1, 它就不是好的散列函数. 最理想的情况是, 将不同的输入映射到不同的数字

### 11.2 散列表

散列函数可以将不同的输入映射为数字, 使用它, 我们就可以打造一款查找速度超快的数据结构, 散列表 (哈希表).

首先创建一个空的数组, 数组的每个位置都对应一个索引.

<img src="%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/1584784156197.png" alt="img" style="zoom:50%;" />

我们将要在这个数组中存储商品的价格.下面首先来将苹果的价格加入到这个数组中. 为此, 将 apple 作为输入交给散列函数.

<img src="%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/1584784217563.png" alt="img" style="zoom:50%;" />

散列函数输出的值是 3, 于是我们就把苹果的价格存放到数组索引为 3 的位置.

<img src="%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/1584785358808.png" alt="img" style="zoom:50%;" />

下面将牛奶 (milk) 的价格存储到数组中. 为此, 将 milk 作为散列函数的输入, 得到结果为 0.

<img src="%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/1584785407641.png" alt="img" style="zoom:50%;" />

散列函数的输出结果为 0, 因此我们将牛奶的价格存储在索引 0 处.

<img src="%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/1584785452638.png" alt="img" style="zoom:50%;" />

不断重复这个过程, 直到整个数组都塞满价格.

<img src="%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/1584785482473.png" alt="img" style="zoom:50%;" />

现在假设需要知道鳄梨 (avocado) 的价格.你无需在数组中査找, 只需将 avocado 作为输入交给散列函数.

<img src="%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/1584785522461.png" alt="img" style="zoom:50%;" />

从而我们得知, 鳄梨的价格存放在数组索引为 4 的位置. 果然, 我们再那里找到了鳄梨的价格.

<img src="%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/1584785564857.png" alt="img" style="zoom:50%;" />

散列函数准确地指出了价格的存储位置, 我们根本不需要进行査找! 之所以能够做到这一点, 具体原因如下:

- 散列函数总是将同样的输入映射到相同的索引. 每次你输入 avocado, 得到的都是同一个数字. 因此, 我们可首先使用它来决定将鳄梨的价格存储在什么地方, 并在以后使用它来得知鳄梨的价格存储在什么地方.
- 散列函数将不同的输入映射到不同的索引. avocado 映射到索引 4, milk 映射到索引 0.每种商品都映射到数组的不同位置, 让你能够将其价格存储到这里.
- 散列函数知道数组有多大, 只返回有效的索引. 如果数组包含 5 个元素, 散列函数就不会返回无效索引 100.

我们刚刚结合使用散列函数和数组创建了一种被称为散列表 (hash table) 的数据结构. 散列表是我们学习的第一种包含额外逻辑的数据结构. 数组和链表都被直接映射到内存, 但散列表更复杂, 它使用散列函数来确定元素的存储位置.

在我们将要学习的复杂数据结构中, 散列表可能是最有用的, 也被称为哈希表、散列映射、映射、字典和关联数组.

散列表的速度很快! 散列表也使用数组来存储数据, 因此其获取元素的速度与数组一样快.

### 11.3 Python 的字典是散列表

我们已经看到, 散列表就是使用类似于键值对的数据存储方式. 事实上, Python 中的字典就是一种散列表数据结构. 于是,  Python 字典的如下性质就很好解释了:

- 字典的键必须是可哈希 (不可变) 的数据类型. 因为必须要通过散列函数把字典的键转换成数字索引才能找到值. 如果键不可哈希, 就无法应用散列函数.
- 字典是无序的 (Python 3.6 以后的版本字典通过其他手段默认有序, 但不影响这里的讨论). 因为值的索引只和键与散列函数有关, 不介意键的顺序. 换句话说, 值的存储是有序的, 但是键不需要顺序.
- 字典的键不能重复. 因为相同内容经过散列函数映射得到的数字一定是相同的. 同一个键只能对应数组的一个索引, 只能对应存储一个值.

### 11.4 应用案例

#### 11.4.1 将散列表用于查找, 模拟映射关系

在下述情况下, 使用散列表是很不错的选择:

- 创建映射
- 查找频繁

电话簿是很符合上面的条件的. 我们要电话簿将姓名映射到电话号码. 该电话簿需要提供如下功能:

- 添加联系人及其电话号码.
- 通过输入联系人来获悉其电话号码

<img src="%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/1584787423452.png" alt="img" style="zoom:33%;" />![img](%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/1584787441215.png)

散列表被用于大海捞针式的查找.例如, 你在访问像 [http://adit.io](http://adit.io/) 这样的网站时, 计算机必须将 adit.io 转换为 IP 地址.

<img src="%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/1584787552832.png" alt="img" style="zoom:50%;" />

事实上, 无论你访问哪个网站, 其网址都必须先转换为 IP 地址.

<img src="%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/1584787616605.png" alt="img" style="zoom:50%;" />

这不是将网址映射到 IP 地址吗? 好像非常适合使用散列表啰! 这个过程被称为 DNS 解析 (DNS resolution) , 散列表是提供这种功能的方式之一.

#### 11.4.2 防止重复

假设你负责管理一个投票站. 显然, 每人只能投一票, 但如何避免重复投票呢? 有人来投票时, 你询问他的全名, 并将其与已投票者名单进行比对.

如果名字在名单中, 就说明这个人投过票了, 因此将他拒之门外!  否则, 就将他的姓名加入到名单中, 并让他投票.  现在假设有很多人来投过了票, 因此名单非常长.

<img src="%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/1584787830599.png" alt="img" style="zoom:33%;" />

每次有人来投票时, 你都得浏览这个长长的名单, 以确定他是否投过票. 但有一种更好的办法, 那就是使用散列表!

<img src="%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/1584788149581.png" alt="img" style="zoom:33%;" />

用代码表示就是:

```python
voted = {}

def check_voter(name: str):
    if voted.get(name):  # 若已经投过票, 让他出去
        print('kick them out!')
    else:
        voted[name] = True  # 若字典中插入此人, 让他投票
        print('let them vote!')

# 测试
check_voter('tom')
check_voter('mike')
check_voter('mike')
```

首先来投票的是 Tom, 上述代码打印 `let them vote!`. 接着 Mike 来投票, 打印的也是 `let them vote!`. 然后, Mike 又来投票, 于是打印的就是 `kick them out!`.

别忘了, 如果你将已投票者的姓名存储在列表中, 这个函数的速度终将变得非常慢, 因为它必须使用简单查找搜索整个列表. 但这里将它们存储在了散列表中, 而散列表让你能够迅速知道来投票的人是否投过票使用散列表来检查是否重复, 速度非常快.

#### 11.4.3将散列表用作缓存

假设你有个侄女, 总是没完没了地问你有关星球的问题. 火星离地球多远? 月球呢? 木星呢? 每次你都得在 Google 搜索, 再告诉她答案.这需要几分钟. 现在假设她老问你月球离地球多远, 很快你就记住了月球离地球 238900 英里. 因此不必再去 Google 搜索, 你就可以直接告诉她答案. 这就是缓存的工作原理: 网站将数据记住, 而不再重新计算.

缓存是一种常用的加速方式, 所有大型网站都使用缓存, 而缓存的数据则存储在散列表中!

### 11.5 冲突

大多数语言都提供了散列表实现, 我们没有必要知道如何实现它们. 有鉴于此, 就不再过多地讨论散列表的内部原理.

但我们依然需要考虑性能! 要明白散列表的性能, 得先搞清楚什么是冲突.

理想的散列函数需要将不同的键映射到数组的不同位置, 但是这种散列函数几乎是不存在的. 有的时候, 不同的数据对应的散列函数的映射值是相同的, 这就产生了**冲突**.

假设我们有一个长度为 26 的数组, 我们使用的散列函数很简单, 按照商品名称的首字母分配位置.

![img](%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/1584790524974.png)

这时候会出现一个问题: 苹果和鳄梨都是以 A 开头, 它们的散列函数的映射值都是 0. 这下可糟了, 一个位置无法存放两个价格信息呀.

![img](%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/1584790602777.png)

这种情况被称为冲突 (collision): 给两个键分配的位置相同. 这是个问题, 如果我们将鳄梨的价格存储到这个位置, 将覆盖苹果的价格, 以后再査询苹果的价格时, 得到的将是鳄梨的价格!

冲突很糟糕, 必须要避免. 处理冲突的方式很多, 最简单的办法为: 如果两个键映射到了同一个位置, 就在这个位置存储一个链表.

![img](%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/1584790703013.png)

在这个例子中, apple 和 avocado 映射到了同一个位置, 因此在这个位置存储一个链表.

在需要査询香蕉的价格时, 速度依然很快.但在需要査询苹果的价格时, 速度要慢些: 我们必须在相应的链表中找到 apple.

如果这个链表很短, 也没什么大不了 —— 只需搜索三四个元素.但是, 假设你工作的杂货店只销售名称以字母 A 打头的商品, 这颗就很糟糕了.

![img](%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/1584790790517.png)

除第一个位置外, 整个散列表都是空的, 而第一个位置包含一个很长的列表! 换言之, 这个散列表中的所有元素都在一个链表中, 这与开始就将所有元素存储到一个链表中一样糟糕: 散列表的速度会很慢.

这里的经验教训有两个:

- 散列函数很重要.前面的散列函数将所有的键都映射到一个位置而最理想的情况是, 散列函数将键均匀地映射到散列表的不同位置.
- 如果散列表存储的链表很长, 散列表的速度将急剧下降. 然而, 如果使用的散列函数很好, 这些链表就不会很长!

### 11.6 性能

散列表、数组和链表的运行时间对比如下.

<img src="%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/1584791656128.png" alt="img" style="zoom:50%;" />

在平均情况下, 散列表执行各种操作所需要的时间都为 O(1).O(1) 被称为常量时间.常量时间并不意味着马上, 而是说不管散列表多大, 所需的时间都相同.

在平均情况下, 散列表的査找 (获取给定索引处的值) 速度与数组一样快, 而插入和删除速度与链表一样快, 因此它兼具两者的优点! 但在最糟情况下, 散列表的各种操作的速度都很慢.

因此, 在使用散列表时避开最糟情况至关重要. 为此, 需要避免冲突. 而要避免冲突, 需要:

- 较低的填装因子
- 良好的散列函数

#### 11.6.1 填装因子

散列表的填装因子很容易计算:

<img src="%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/1584792189596.png" alt="img" style="zoom:50%;" />

散列表使用数组来存储数据, 因此我们需要计算数组中被占用的位置数. 例如, 下述散列表的填装因子为 2/5, 即 0.4.

<img src="%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/1584792243587.png" alt="img" style="zoom:50%;" />

填装因子大于 1 意味着商品数量超过了数组的位置数. 一旦填装因子开始增大, 就需要在散列表中添加位置, 这被称为调整长度 (resizing). 例如, 假设有一个像下面这样相当满的散列表.

<img src="%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/1584792332516.png" alt="img" style="zoom:50%;" />

我们就需要调整它的长度.为此, 首先创建一个更长的新数组: 通常将数组增长一倍.

<img src="%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/1584792361103.png" alt="img" style="zoom:50%;" />

接下来, 我们需要使用散列函数将所有的元素都插入到这个新的散列表种.

<img src="%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/1584792397294.png" alt="img" style="zoom:50%;" />

这个新散列表的填装因子为 3/8, 比原来低多了!填装因子越低, 发生冲突的可能性越小, 散列表的性能越高. 一个不错的经验规则是: 一旦填装因子大于 0.7, 就调整散列表的长度.

调整散列表长度的工作需要很长时间. 但平均而言, 即便考虑到调整长度所需的时间, 散列表操作所需的时间也为 O(1).

#### 11.6.2 良好的散列函数

良好的散列函数让数组中的值呈均匀分布.

<img src="%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/1584792547299.png" alt="img" style="zoom:50%;" />

糟糕的散列函数让值扎堆, 导致大量冲突.

<img src="%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/1584792584050.png" alt="img" style="zoom:50%;" />

什么样的散列函数是良好的呢? 这个问题我们大可不必操心 —— 天塌下来有高个子顶着, 早就有大牛帮我们实现了. 如果你好奇, 可研究一下 SHA 函数, 我们可将它用作散列函数.

## 12. 广度优先搜索

> 广度优先搜索让我们能够找出两样东西之间的最短距离. 广度优先搜索是一种用于图的查找算法, 可帮助回答两类问题: 1. 从节点 A 出发, 有前往节点 B 的路径吗? 2. 从节点 A 出发, 前往节点 B 的哪条路径最短?

广度优先搜索让我们能够找出两样东西之间的最短距离. 不过最短距离的含义有很多, 使用广度优先搜索可以:

- 编写国际跳棋 AI, 计算最少走多少步就可获胜
- 编写拼写检査器, 计算最少编辑多少个地方就可将错拼的单词改成正确的单词, 如将 READED 改为 READER 只编辑一个字母改如何操作
- 根据你的人际关系网络找到关系最近的医生.

### 12.1 图简介

假设你居住在旧金山, 要从双子峰前往金门大桥. 你想乘公交车前往, 并希望换乘最少. 可乘坐的公交车如下:

<img src="%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/1585495772598.png" alt="img" style="zoom:50%;" />

显然, 我们至少需要三步才能从双子峰走到金门大桥:

<img src="%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/1585495818790.png" alt="img" style="zoom:50%;" />

当然还有其他前往金门大桥的路线, 但它们更远 (需要四步). 这种问题被称为最短路径问题 (shortest-path problem).

我们经常要找出最短路径, 这可能是前往朋友家的最短路径, 也可能是国际象棋中把对方将死的最少步数.解决最短路径问题的算法被称为广度优先搜索.

要确定如何从双子峰前往金门大桥, 需要两个步骤:

1. 使用图来建立问题模型.
2. 使用广度优先搜索解决问题.

图模拟一组连接. 例如, 假设你与朋友玩牌, 并要模拟谁欠谁钱, 可像下面这样指出 Alex 欠 Rama 钱:

<img src="%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/1585495990061.png" alt="img" style="zoom:50%;" />

完整的欠钱关系图可能是这样的:

<img src="%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/1585496028861.png" alt="img" style="zoom:50%;" />

Alex 欠 Rama 钱, Tom 欠 Adit 钱, 等等. 图由节点 (node) 和边 (edge) 组成:

<img src="%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/1585496094162.png" alt="img" style="zoom:50%;" />

一个节点可能与众多节点直接相连, 这些节点被称为邻居. 在前面的欠钱图中, Rama 是 Alex 的邻居. Adit 不是 Alex 的邻居, 因为他们不直接相连. 但 Adit 既是 Rama 的邻居, 又是 Tom 的邻居.

图用于模拟不同的东西是如何相连的.

广度优先搜索是一种用于图的查找算法, 可帮助回答两类问题:

1. 从节点 A 出发, 有前往节点 B 的路径吗?
2. 从节点 A 出发, 前往节点 B 的哪条路径最短?

前面计算从双子峰前往金门大桥的最短路径的问题, 就属于第二类问题: 哪条路径最短?

假设你经营着一个芒果农场, 需要寻找芒果销售商, 以便将芒果卖给他. 在 Facebook, 你与芒果销售商有联系吗? 为此, 你可以在朋友中查找.

首先, 创建一个朋友的清单, 然后依次检查每个朋友, 看他是否是芒果经销商. 如果是, 则大功告成, 否则查看下一个朋友.

如果你的朋友没有任何一个人是芒果经销商, 你就需要在朋友的朋友中寻找:

<img src="%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/1585496587854.png" alt="img" style="zoom:50%;" />

这次, 你还是从自己的朋友开始找起. 不同的是, 如果你的朋友不是经销商, 你就把朋友的人际关系, 也就是朋友的所有朋友也加入到查找清单中.

<img src="%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/1585496660449.png" alt="img" style="zoom:50%;" />

这样一来, 你不仅在朋友中查找, 还在朋友的朋友中查找. 别忘了, 你的目标是在人际关系网中找到一位芒果销售商. 因此, 如果 Alice 不是芒果销售商, 就将其朋友也加入到名单中. 这意味着你将在她的朋友、朋友的朋友等中査找. 使用这种算法将搜遍你的整个人际关系网, 直到找到芒果销售商. 这就是广度优先搜索算法

### 12.2 查找最短路径

再说一次, 广度优先搜索可回答两类问题:

1. 从节点 A 出发, 有前往节点 B 的路径吗? (在你的人际关系网中, 有芒果销售商吗?) 
2. 从节点 A 出发, 前往节点 B 的哪条路径最短? (哪个芒果销售商与你的关系最近?) 

刚刚我们讨论了如何回答第一类问题, 下面来尝试回答第二类问题 —— 谁是关系最近的芒果销售商. 例如, 朋友是一度关系, 朋友的朋友是二度关系

显而易见, 一度关系胜过二度关系, 二度关系胜过三度关系, 以此类推. 因此, 你应先在一度关系中搜索, 确定其中没有芒果销售商后, 才在二度关系中搜索.

广度优先搜索就是这样做的! 在广度优先搜索的执行过程中, 搜索范围从起点开始逐渐向外延伸. 即先检查一度关系, 再检查二度关系.

Claire 是一度关系, 而 Anuj 是二度关系, 因此将先检查 Claire, 后检查 Anuj. 你也可以这样看, 一度关系在二度关系之前加入查找名单. 你按顺序依次检査名单中的每个人, 看看他是否是芒果销售商. 这将先在一度关系中查找, 再在二度关系中查找, 因此找到的是关系最近的芒果销售商. 广度优先搜索不仅査找从 A 到 B 的路径, 而且找到的是最短的路径.

<img src="%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/1585544498067.png" alt="img" style="zoom:50%;" />

注意, 只有按添加顺序査找时, 才能实现这样的目的. 换句话说, 如果 Claire 先于 Anuj 加入名单, 就需要先检查 Claire, 再检查 Anuj. 如果 Claire 和 Anuj 都是芒果销售商, 而你先检查 Anuj 再检查 Claire, 结果将如何呢? 找到的芒果销售商并非是与你关系最近的, 因为 Anuj 是你朋友的朋友, 而 Claire 是你的朋友. 因此, 你需要按添加顺序进检查.

这种先添加先检查的数据结构, 就是队列.

### 12.3 队列

队列类似于栈, 你不能随机地访问队列中的元素. 队列只支持两种操作: 入队和出队.

<img src="%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/1585582209888.png" alt="img" style="zoom:50%;" />

如果你将两个元素加入队列, 先加入的元素将在后加入的元素之前出队. 因此, 你可使用队列来表示査找名单, 这样, 先加入的人将先出队并先被检查.

队列是一种先进先出 (First in first out, FIFO) 的数据结构, 而栈是种后进先出 (Last in first out, LIFO) 的数据结构.

<img src="%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/1585582311086.png" alt="img" style="zoom:50%;" />

### 12.4 Python 代码实现图

接下来, 我们要用 Python 代码实现图.

图由多个节点组成.节点之间有相互关联的关系.我们可以通过散列表来表示这种关系.

我们要将我们和朋友建立起一种映射关系.

<img src="%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/1585582936747.png" alt="img" style="zoom:50%;" />

这种映射关系可以用散列表表示:

```python
graph = {}
graph['you'] = ['alice', 'bob', 'claire']
```

图不过是一系列的节点和边, 因此在 Python 中, 只需使用上述代码就可表示一个图.

对于像下面这种比较复杂的图, 我们同样可以采用上面的思路, 只不过需要多写几个中间节点而已.

<img src="%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/1585583225926.png" alt="img" style="zoom:50%;" />

用 Python 代码表示这个图中的关系就是:

```python
graph = {}
graph['you'] = ['alice', 'bob', 'claire']
graph['bob'] = ['anuj', 'peggy']
graph['alice'] = ['peggy']
graph['claire'] = ['thom', 'jonny']
graph['anuj'] = []
graph['peggy'] = []
graph['thom'] = []
graph['jonny'] = []
```

Anuj、 Peggy、Thom 和 Jonny 都没有邻居, 这是因为虽然有指向他们的箭头, 但没有从他们出发指向其他人的箭头. 这被称为有向图 (directed graph) , 其中的关系是单向的. 因此, Anuj 是 Bob 的邻居, 但 Bob 不是 Anuj 的邻居. 无向图 (undirected graph) 没有箭头, 直接相连的节点互为邻居. 例如, 下面两个图是等价的.

<img src="%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/1585583539128.png" alt="img" style="zoom:50%;" />

### 12.5 实现算法

算法的工作原理为:

<img src="%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/1585583593464.png" alt="img" style="zoom:50%;" />

首先, 创建一个队列. 在 Python 中, 可使用函数 `deque()` 来创建一个双端队列:

```python
from collections import deque
search_queue = deque()    # 创建一个队列
search_queue += graph['you']    # 将你的邻居加入到队列中
```

下面是查看朋友圈中是否有芒果经销商的完整函数代码:

```python
def search(graph):
    search_queue = deque()  # 创建一个队列
    search_queue += graph['you']  # 将你的邻居加入到队列中
    while search_queue:    # 只要队列不为空
        person = search_queue.popleft()    # 就取出队列中的第一个人
        if person_is_seller(person):    # 检查这个人是否是芒果经销商
            print(person, 'is a seller!')    # 是芒果经销商
            return True
        else:
            search_queue += graph[person]    # 不是芒果经销商, 把这个人的朋友圈都加入到队列中
    return False    # 如果到达这里, 就说明队列中没有芒果经销商
```

我们可以定义一个判断一个人是否是芒果经销商的函数:

```python
def person_is_seller(name):
    return name[-1] == 'm'
```

通过一个人名字是否是以 m 结尾来判断他是不是芒果经销商, 这在现实中很荒谬, 但是给我们做例子已经足够了.

下面是广度优先搜索的执行过程:

<img src="%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/1585588829384.png" alt="img" style="zoom:50%;" />

这个算法将不断执行, 直到满足以下条件之一:

- 找到一位芒果销售商;
- 队列变成空的, 这意味着你的人际关系网中没有芒果销售商.

我们前面的代码并不完善, 比如 Peggy 既是 Alie 的朋友又是 Bob 的朋友, 因此她将被加入队列两次: 一次是在添加 Alice 的朋友时, 另一次是在添加 Bob 的朋友时. 因此, 搜索队列将包含两个 Peggy.

在这个问题中不会出现差错, 但是对于有循环关系网的时候, 我们有可能会陷入无限循环中.

<img src="%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/1585589015841.png" alt="img" style="zoom:50%;" />

为了避免这种情况发生, 我们需要限制, 已经处检查的人将不会被重复检查.

这时, 我们可以创建一个列表, 专门存放已经检查过的人. 如果下一个要检查的人出现在这个列表中, 我们可以直接跳过, 不去检查.

考虑到这一点, 广度优先搜索算法的最终版本为:

```python
from collections import deque

graph = {}
graph['you'] = ['alice', 'bob', 'claire']
graph['bob'] = ['anuj', 'peggy']
graph['alice'] = ['peggy']
graph['claire'] = ['thom', 'jonny']
graph['anuj'] = []
graph['peggy'] = []
graph['thom'] = []
graph['jonny'] = []

def person_is_seller(name):
    return name[-1] == 'm'

def search(graph, name='you'):
    search_queue = deque()  # 创建一个队列
    search_queue += graph[name]  # 将你的邻居加入到队列中
    searched = []    # 这个数组用于存放已经检查过的人
    while search_queue:    # 只要队列不为空
        person = search_queue.popleft()    # 就取出队列中的第一个人
        if person not in searched:    # 仅当这个人没有被检查的时候, 才会被检查
            if person_is_seller(person):    # 检查这个人是否是芒果经销商
                print(person, 'is a seller!')    # 是芒果经销商
                return True
            else:
                search_queue += graph[person]    # 不是芒果经销商, 把这个人的朋友圈都加入到队列中
                searched.append(person)    # 将这个人标记为已经检查过
    return False    # 如果到达这里, 就说明队列中没有芒果经销商

search(graph, 'you')
```

### 12.6 运行时间

如果你在你的整个人际关系网中搜索芒果销售商, 就意味着你将沿每条边前行 (记住, 边是从一个人到另一个人的箭头或连接) , 因此运行时间至少为 $O (边数)$. 你还使用了一个队列, 其中包含要检查的每个人.将一个人添加到队列需要的时间是固定的, 即为 $O (1)$, 因此对每个人都这样做需要的总时间为 $O (人数)$.所以, 广度优先搜索的运行时间为 $O (人数 + 边数)$, 这通常写作 $O (V+E)$, 其中 V 为顶点 (vertice) 数, E 为边数.

## 13. 狄克斯特拉算法

> 狄克斯特拉算法用来找到加权图中的最短路径. 广度优先搜索可以找到段数最少的路径, 但是如果我们要找到用时最少的路径, 就要使用狄克斯特拉算法 (Dijkstra's Algorithm) .

广度优先搜索可以找到段数最少的路径, 但是如果我们要找到用时最少的路径, 就要使用狄克斯特拉算法 (Dijkstra’s Algorithm) .

<img src="%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/1585634441563.png" alt="img" style="zoom:50%;" />

### 13.1 狄克斯特拉算法的使用思路

下面这张图中, 每个数字表示的都是时间, 单位分钟.为找出从起点到终点耗时最短的路径, 我们需要使用狄克斯特拉算法.

<img src="%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/1585635691679.png" alt="img" style="zoom:50%;" />

如果使用广度优先搜索, 将得到下面这条段数最少的路径.

<img src="%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/1585635897343.png" alt="img" style="zoom:50%;" />

这条路径耗时 7 分钟.下面来看看能否找到耗时更短的路径.

狄克斯特拉算法包含 4 个步骤:

1. 找出 “最便宜” 的节点, 即可在最短时间内到达的节点.
2. 更新该节点的邻居的开销, 其含义将稍后介绍.
3. 重复这个过程, 直到对图中的每个节点都这样做了.
4. 计算最终路径.

第一步: 找出最便宜的节点. 你站在起点, 不知道该前往节点 A 还是前往节点 B.前往这两个节点都要多长时间呢?

前往节点 A 需要 6 分钟, 而前往节点 B 需要 2 分钟. 至于前往其他节点, 我们暂且还不知道需要多长时间.

<img src="%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/1585636064788.png" alt="img" style="zoom:50%;" />

由于我们还不知道前往终点需要多长时间, 因此先假设为无穷大.节点 B 是最近的 —— 2 分钟就能达到.

第二步: 计算经节点 B 前往其各个邻居所需的时间.

<img src="%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/1585719863650.png" alt="img" style="zoom:50%;" />

这时, 我们发现了到 A 点和终点的更短时间, 前往 A 点的时间从 6 分钟缩短到 5 分钟, 前往终点的时间降低到 7 分钟.然后我们就把这两个新的更短的时间更新到表格中.

第三步:重复.

重复第一步, 找出可在最短时间内前往的节点. 我们已经对节点 B 执行了前两步, 除节点 B 外, 可在最短时间内前往的节点是节点 A.

<img src="%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/1585721566146.png" alt="img" style="zoom:50%;" />

重复第二步, 更新节点 A 的所有邻居的开销:

<img src="%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/1586238724971.png" alt="img" style="zoom:50%;" />

这时我们发现从节点 A 前往终点的时间只需要 6 分钟!

至此, 我们对每个节点都运行了狄克斯特拉算法 (无需对终点这样做). 现在, 我们知道:

- 前往节点 B 需要 2 分钟；
- 前往节点 A 需要 5 分钟；
- 前往终点需要 6 分钟.

<img src="%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/1586238842092.png" alt="img" style="zoom:50%;" />

最后一步, 计算得到最终路径.

<img src="%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/1586238864744.png" alt="img" style="zoom:50%;" />

如果使用广度优先搜索, 找到的最短路径将不是这条. 因为这条路径包含 3 段, 而有一条从起点到终点的路径只有 2 段.

<img src="%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/1586238933902.png" alt="img" style="zoom:50%;" />

使用广度优先搜索可以査找两点之间的最短路径. 这里的最短路径的意思是段数最少. 在狄克斯特拉算法中, 我们给每段都分配了一个数字或权重, 因此狄克斯特拉算法找出的是总权重最小的路径.

**狄克斯特拉算法流程小结**

狄克斯特拉算法包含 4 个步骤:

1. 找到最便宜的节点, 即从起点开始, 可在最短时间内前往的节点
2. 对于该节点的邻居, 检査是否有前往它们的更短路径, 如果有, 就更新其开销
3. 重复这个过程, 直到对图中的每个节点都这样做了, 终点是不需要计算的
4. 计算最终路径.

### 13.2 术语

狄克斯特拉算法用于每条边都有关联数字的图, 这些数字称为权重 (weight).

<img src="%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/1586241590374.png" alt="img" style="zoom:50%;" />

带权重的图称为**加权图 (weighted graph)** , 不带权重的图称为**非加权图 (unweighted graph)**.

<img src="%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/1586241685984.png" alt="img" style="zoom:50%;" />

要计算非加权图中的最短路径, 可使用广度优先搜索. 要计算加权图中的最短路径, 可使用狄克斯特拉算法.

图还可能有环, 环类似下面这样:

<img src="%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/1586251064073.png" alt="img" style="zoom:50%;" />

如果路径中出现了环, 使用狄克斯特拉算法将会进入一个死循环:

<img src="%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/1586253462316.png" alt="img" style="zoom:50%;" />

无向图意味着两个节点都指向对方, 本质上也是一个环.

<img src="%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/1586253515948.png" alt="img" style="zoom:50%;" />

在无向图中, 每条边都是一个环.狄克斯特拉算法只适用于**有向无环图 (directed acyclic graph, DAG)**.

### 13.3 示例: 乐谱换钢琴

Rama 想要用一本乐谱换钢琴.

Alex 说: "这是我最喜欢的乐队 Destroyer 的海报, 我愿意拿它换你的乐谱. 如果你再加 5 美元, 还可拿乐谱换我这张稀有的 Rick Astley 黑胶唱片."

Amy 说: "哇, 我听说这张黑胶唱片里有首非常好听的歌曲, 我愿意拿我的吉他和架子鼓换这张海报和黑胶唱片."

Beethoven 惊呼: "我一直想要吉他, 我愿意拿我的钢琴换 Amy 的吉他或架子鼓."

太好了! 只要再花一点点钱, Rama 就能拿乐谱换架钢琴. 现在他需要确定的是, 如何花最少的钱实现这个目标. 我们来绘制一个图, 列出大家的交换意愿.

<img src="%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/1586321386244.png" alt="img" style="zoom:50%;" />

这个图中的节点是大家愿意拿出来交换的东西, 边的权重是交换时需要额外加多少钱. 比如, 拿海报换吉他需要额外加 30 美元, 拿黑胶唱片换吉他需要额外加 15 美元.

Rana 需要确定采用哪种路径将乐谱换成钢琴时需要支付的额外费用最少. 为此, 可以使用狄克斯特拉算法!

别忘了, 狄克斯特拉算法包含四个步骤. 在这个示例中, 我们将完成所有这些步骤, 因此我们也将计算最终路径.

动手之前, 我们先做些准备工作: 创建一个表格, 在其中列出每个节点的开销.这里的开销指的是达到节点需要额外支付多少钱.

<img src="%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/1586321487829.png" alt="img" style="zoom:50%;" />

在执行狄克斯特拉算法的过程中, 我们将不断更新这个表.

为计算最终路径, 还需在这个表中添加表示父节点的列.

<img src="%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/1586321763008.png" alt="img" style="zoom:50%;" />

第一步: 找出最便宜的节点. 在这里, 换海报最便宜, 不需要支付额外的费用.

还有更便宜的换海报的途径吗? 这一点非常重要, 决定了狄克斯特拉算法是否能够为我们找到花费最少的方法. Rama 能够通过一系列交换得到海报, 还能额外得到钱吗?

答案是不能, 因为海报是 Rama 能够到达的最便宜的节点, 没法再便宜了. 下面提供了另一种思考角度. 假设你要从家里去单位.

<img src="%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/1586322029813.png" alt="img" style="zoom:50%;" />

如果你走经过学校的路, 到学校需要 2 分钟. 如果走经过停车场的路, 到停车场需要 6 分钟.

如果经停车场前往学校, 能不能将时间缩短到少于 2 分钟呢? 不可能, 因为只前往停车场就需要 6 分钟.

另一方面, 有没有能更快到达停车场的路呢? 有.

<img src="%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/1586322321142.png" alt="img" style="zoom:50%;" />

这就是狄克斯特拉算法背后的关键理念: 找出图中最便宜的节点, 并确保没有到该节点的更便宜的路径!

第二步: 计算前往该节点 (也就是海报) 的各个邻居的开销.

<img src="%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/1586322516600.png" alt="img" style="zoom: 67%;" />

现在的表中更新了低音吉他和架子鼓的开销. 这些开销是用海报交换它们时需要支付的额外费用, 因此父节点为海报. 这意味着, 要到达低音吉他, 需要沿从海报出发的边前行, 对架子鼓来说亦如此.

再次执行第一步: 下一个最便宜的节点是黑胶唱片 —— 需要额外支付 5 美元.

再次执行第二步: 更新黑胶唱片的各个邻居的开销.

<img src="%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/1586325482703.png" alt="img" style="zoom:50%;" />

我们更新了架子鼓和吉他的开销! 这意味着经 "黑胶唱片" 前往 "架子鼓" 和 "吉他" 的开销更低, 因此我们将这些乐器的父节点改成了黑胶唱片.

再次重复. 下一个最便宜的是吉他, 我们接下来就要更新吉他的邻居的开销.

<img src="%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/1586325605771.png" alt="img" style="zoom:50%;" />

最后, 对最后一个节点, 架子鼓, 进行同样的处理.

<img src="%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/1586325753029.png" alt="img" style="zoom:50%;" />

如果用架子鼓换钢琴, Rama 需要额外支付的费用更少. 因此, 采用最便宜的交换路径时, Rama 需要额外支付 35 美元.

现在我们要确定最终的路径. 当前, 我们已经知道最短路径的开销为 35 美元, 但如何确定这条路径呢? 为此, 先找出钢琴的父节点.

<img src="%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/1586326041396.png" alt="img" style="zoom:50%;" />

钢琴的父节点为架子鼓, 架子鼓的父节点为黑胶唱片, 黑胶唱片的父节点为乐谱. 通过沿父节点回溯, 我们就找到了完整的交换路径.

<img src="%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/1586326390586.png" alt="img" style="zoom:50%;" />

前面使用的都是术语最短路径的字面意思: 计算两点或两人之间的最短路径. 但希望这个示例让你明白, 最短路径指的并不一定是物理距离, 也可能是让某种度量指标最小.

在这个示例中, 最短路径指的是 Rama 想要额外支付的费用最少. 这都要归功于狄克斯特拉!

### 13.4 负权边

前面的例子中, 所有的权重都是正的. 如果有一个边的权重为负, 会怎么样呢?

假设黑胶唱片不是 Alex 的, 而是 Sarah 的, 且 Sarah 愿意用黑胶唱片和 7 美元换海报. 换句话说, 换得 Alex 的海报后, Rama 用它来换 Sarah 的黑胶唱片时, 不但不用支付额外的费用, 还可得 7 美元.对于这种情况, 如何在图中表示出来呢?

<img src="%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/1586414179140.png" alt="img" style="zoom:50%;" />

从黑胶唱片到海报的边的权重为负!即这种交换让 Rama 能够得到 7 美元.现在, Rama 有两种获得海报的方式.

<img src="%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/1586414427973.png" alt="img" style="zoom:50%;" />

第二种方式更划算 —— Rama 可赚 2 美元! 你可能还记得, Rama 可以用海报换架子鼓, 但现在有两种换得架子鼓的方式.

<img src="%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/1586414468509.png" alt="img" style="zoom:50%;" />

第二种方式的开销少 2 美元, 他应采取这种方式.

然而, 如果我们对这图运行狄克斯特拉算法, Rama 将选择错误的路径 — 更长的那条路径.如果有负权边, 就不能使用狄克斯特拉算法.因为负权边会导致这种算法不管用.

下面来看看对这个图执行狄克斯特拉算法的情况.首先, 创建开销表.

<img src="%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/1586414540900.png" alt="img" style="zoom:50%;" />

接下来, 找出开销最低的节点, 并更新其邻居的开销. 在这里, 开销最低的节点是海报. 根据狄克斯特拉算法, 没有比不支付任何费用获得海报更便宜的方式. (但其实这并不对!) 无论如何, 我们来更新其邻居的开销.

<img src="%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/1586414591327.png" alt="img" style="zoom:50%;" />

现在, 架子鼓的开销变成了 35 美元.
我们来找出最便宜的未处理节点, 也就是黑胶唱片.

<img src="%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/1586414866088.png" alt="img" style="zoom:50%;" />

更新黑胶唱片邻居节点.

<img src="%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/1586414897663.png" alt="img" style="zoom:50%;" />

海报节点已处理过, 这里却更新了它的开销. 这是一个危险信号: 节点一旦被处理, 就意味着没有前往该节点的更便宜途径.但我们刚才却找到了前往海报节点的更便宜途径!

架子鼓没有任何邻居, 因此算法到此结束, 最终开销如下.

<img src="%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.assets/1586414960559.png" alt="img" style="zoom:50%;" />

换得架子鼓的开销为 35 美元.但我们知道其实还有一种交换方式只需 33 美元, 但狄克斯特拉算法没有找到. 这是因为狄克斯特拉算法这样假设: 对于处理过的海报节点, 没有前往该节点的更短路径. 这种假设仅在没有负权边时才成立. 因此, 不能将狄克斯特拉算法用于包含负权边的图. 在包含负权边的图中, 要找出最短路径, 可使用另一种算法 —— 贝尔曼・福德算法 (Bellman-Ford algorithm).